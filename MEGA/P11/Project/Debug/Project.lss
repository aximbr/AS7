
Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000228  00800200  00001e38  00001ecc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e38  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001295  00800428  00800428  000020f4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000020f4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002124  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004a8  00000000  00000000  00002164  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006814  00000000  00000000  0000260c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c94  00000000  00000000  00008e20  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000344d  00000000  00000000  0000aab4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e2c  00000000  00000000  0000df04  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001e5b  00000000  00000000  0000ed30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005a6f  00000000  00000000  00010b8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000570  00000000  00000000  000165fa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b0 c0       	rjmp	.+352    	; 0x162 <__ctors_end>
       2:	00 00       	nop
       4:	ce c0       	rjmp	.+412    	; 0x1a2 <__bad_interrupt>
       6:	00 00       	nop
       8:	cc c0       	rjmp	.+408    	; 0x1a2 <__bad_interrupt>
       a:	00 00       	nop
       c:	ca c0       	rjmp	.+404    	; 0x1a2 <__bad_interrupt>
       e:	00 00       	nop
      10:	c8 c0       	rjmp	.+400    	; 0x1a2 <__bad_interrupt>
      12:	00 00       	nop
      14:	c6 c0       	rjmp	.+396    	; 0x1a2 <__bad_interrupt>
      16:	00 00       	nop
      18:	c4 c0       	rjmp	.+392    	; 0x1a2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c2 c0       	rjmp	.+388    	; 0x1a2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c0 c0       	rjmp	.+384    	; 0x1a2 <__bad_interrupt>
      22:	00 00       	nop
      24:	be c0       	rjmp	.+380    	; 0x1a2 <__bad_interrupt>
      26:	00 00       	nop
      28:	bc c0       	rjmp	.+376    	; 0x1a2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	ba c0       	rjmp	.+372    	; 0x1a2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	b8 c0       	rjmp	.+368    	; 0x1a2 <__bad_interrupt>
      32:	00 00       	nop
      34:	b6 c0       	rjmp	.+364    	; 0x1a2 <__bad_interrupt>
      36:	00 00       	nop
      38:	b4 c0       	rjmp	.+360    	; 0x1a2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b2 c0       	rjmp	.+356    	; 0x1a2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b0 c0       	rjmp	.+352    	; 0x1a2 <__bad_interrupt>
      42:	00 00       	nop
      44:	ae c0       	rjmp	.+348    	; 0x1a2 <__bad_interrupt>
      46:	00 00       	nop
      48:	ac c0       	rjmp	.+344    	; 0x1a2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	aa c0       	rjmp	.+340    	; 0x1a2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	a8 c0       	rjmp	.+336    	; 0x1a2 <__bad_interrupt>
      52:	00 00       	nop
      54:	a6 c0       	rjmp	.+332    	; 0x1a2 <__bad_interrupt>
      56:	00 00       	nop
      58:	a4 c0       	rjmp	.+328    	; 0x1a2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a2 c0       	rjmp	.+324    	; 0x1a2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a0 c0       	rjmp	.+320    	; 0x1a2 <__bad_interrupt>
      62:	00 00       	nop
      64:	9e c0       	rjmp	.+316    	; 0x1a2 <__bad_interrupt>
      66:	00 00       	nop
      68:	9c c0       	rjmp	.+312    	; 0x1a2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	9a c0       	rjmp	.+308    	; 0x1a2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	98 c0       	rjmp	.+304    	; 0x1a2 <__bad_interrupt>
      72:	00 00       	nop
      74:	96 c0       	rjmp	.+300    	; 0x1a2 <__bad_interrupt>
      76:	00 00       	nop
      78:	94 c0       	rjmp	.+296    	; 0x1a2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	92 c0       	rjmp	.+292    	; 0x1a2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	f0 c4       	rjmp	.+2528   	; 0xa62 <__vector_32>
      82:	00 00       	nop
      84:	8e c0       	rjmp	.+284    	; 0x1a2 <__bad_interrupt>
      86:	00 00       	nop
      88:	8c c0       	rjmp	.+280    	; 0x1a2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8a c0       	rjmp	.+276    	; 0x1a2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	88 c0       	rjmp	.+272    	; 0x1a2 <__bad_interrupt>
      92:	00 00       	nop
      94:	86 c0       	rjmp	.+268    	; 0x1a2 <__bad_interrupt>
      96:	00 00       	nop
      98:	84 c0       	rjmp	.+264    	; 0x1a2 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	82 c0       	rjmp	.+260    	; 0x1a2 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	80 c0       	rjmp	.+256    	; 0x1a2 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	7e c0       	rjmp	.+252    	; 0x1a2 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7c c0       	rjmp	.+248    	; 0x1a2 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7a c0       	rjmp	.+244    	; 0x1a2 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	78 c0       	rjmp	.+240    	; 0x1a2 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	76 c0       	rjmp	.+236    	; 0x1a2 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	74 c0       	rjmp	.+232    	; 0x1a2 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	72 c0       	rjmp	.+228    	; 0x1a2 <__bad_interrupt>
      be:	00 00       	nop
      c0:	70 c0       	rjmp	.+224    	; 0x1a2 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	6e c0       	rjmp	.+220    	; 0x1a2 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6c c0       	rjmp	.+216    	; 0x1a2 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6a c0       	rjmp	.+212    	; 0x1a2 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	68 c0       	rjmp	.+208    	; 0x1a2 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	66 c0       	rjmp	.+204    	; 0x1a2 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	64 c0       	rjmp	.+200    	; 0x1a2 <__bad_interrupt>
      da:	00 00       	nop
      dc:	62 c0       	rjmp	.+196    	; 0x1a2 <__bad_interrupt>
      de:	00 00       	nop
      e0:	60 c0       	rjmp	.+192    	; 0x1a2 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ae 0e       	add	r10, r30
      e6:	ae 0e       	add	r10, r30
      e8:	ae 0e       	add	r10, r30
      ea:	e4 0e       	add	r14, r20
      ec:	d4 0e       	add	r13, r20
      ee:	e1 0e       	add	r14, r17
      f0:	ae 0e       	add	r10, r30
      f2:	ae 0e       	add	r10, r30
      f4:	e4 0e       	add	r14, r20
      f6:	d4 0e       	add	r13, r20

000000f8 <prvIdleTask>:
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
      f8:	09 e4       	ldi	r16, 0x49	; 73
      fa:	16 e1       	ldi	r17, 0x16	; 22
      fc:	0f 2e       	mov	r0, r31
      fe:	f1 e7       	ldi	r31, 0x71	; 113
     100:	ef 2e       	mov	r14, r31
     102:	f6 e1       	ldi	r31, 0x16	; 22
     104:	ff 2e       	mov	r15, r31
     106:	f0 2d       	mov	r31, r0
     108:	80 91 48 16 	lds	r24, 0x1648	; 0x801648 <uxDeletedTasksWaitingCleanUp>
     10c:	88 23       	and	r24, r24
     10e:	11 f1       	breq	.+68     	; 0x154 <prvIdleTask+0x5c>
     110:	0f b6       	in	r0, 0x3f	; 63
     112:	f8 94       	cli
     114:	0f 92       	push	r0
     116:	d8 01       	movw	r26, r16
     118:	15 96       	adiw	r26, 0x05	; 5
     11a:	ed 91       	ld	r30, X+
     11c:	fc 91       	ld	r31, X
     11e:	16 97       	sbiw	r26, 0x06	; 6
     120:	c6 81       	ldd	r28, Z+6	; 0x06
     122:	d7 81       	ldd	r29, Z+7	; 0x07
     124:	ce 01       	movw	r24, r28
     126:	02 96       	adiw	r24, 0x02	; 2
     128:	e3 d2       	rcall	.+1478   	; 0x6f0 <uxListRemove>
     12a:	80 91 3e 16 	lds	r24, 0x163E	; 0x80163e <uxCurrentNumberOfTasks>
     12e:	81 50       	subi	r24, 0x01	; 1
     130:	80 93 3e 16 	sts	0x163E, r24	; 0x80163e <uxCurrentNumberOfTasks>
     134:	80 91 48 16 	lds	r24, 0x1648	; 0x801648 <uxDeletedTasksWaitingCleanUp>
     138:	81 50       	subi	r24, 0x01	; 1
     13a:	80 93 48 16 	sts	0x1648, r24	; 0x801648 <uxDeletedTasksWaitingCleanUp>
     13e:	0f 90       	pop	r0
     140:	0f be       	out	0x3f, r0	; 63
     142:	8f 89       	ldd	r24, Y+23	; 0x17
     144:	98 8d       	ldd	r25, Y+24	; 0x18
     146:	0c d2       	rcall	.+1048   	; 0x560 <vPortFree>
     148:	ce 01       	movw	r24, r28
     14a:	0a d2       	rcall	.+1044   	; 0x560 <vPortFree>
     14c:	80 91 48 16 	lds	r24, 0x1648	; 0x801648 <uxDeletedTasksWaitingCleanUp>
     150:	81 11       	cpse	r24, r1
     152:	de cf       	rjmp	.-68     	; 0x110 <prvIdleTask+0x18>
     154:	f7 01       	movw	r30, r14
     156:	80 81       	ld	r24, Z
     158:	82 30       	cpi	r24, 0x02	; 2
     15a:	08 f0       	brcs	.+2      	; 0x15e <prvIdleTask+0x66>
     15c:	ab d3       	rcall	.+1878   	; 0x8b4 <vPortYield>
     15e:	31 d2       	rcall	.+1122   	; 0x5c2 <vApplicationIdleHook>
     160:	d3 cf       	rjmp	.-90     	; 0x108 <prvIdleTask+0x10>

00000162 <__ctors_end>:
     162:	11 24       	eor	r1, r1
     164:	1f be       	out	0x3f, r1	; 63
     166:	cf ef       	ldi	r28, 0xFF	; 255
     168:	d1 e2       	ldi	r29, 0x21	; 33
     16a:	de bf       	out	0x3e, r29	; 62
     16c:	cd bf       	out	0x3d, r28	; 61
     16e:	00 e0       	ldi	r16, 0x00	; 0
     170:	0c bf       	out	0x3c, r16	; 60

00000172 <__do_copy_data>:
     172:	14 e0       	ldi	r17, 0x04	; 4
     174:	a0 e0       	ldi	r26, 0x00	; 0
     176:	b2 e0       	ldi	r27, 0x02	; 2
     178:	e8 e3       	ldi	r30, 0x38	; 56
     17a:	fe e1       	ldi	r31, 0x1E	; 30
     17c:	00 e0       	ldi	r16, 0x00	; 0
     17e:	0b bf       	out	0x3b, r16	; 59
     180:	02 c0       	rjmp	.+4      	; 0x186 <__do_copy_data+0x14>
     182:	07 90       	elpm	r0, Z+
     184:	0d 92       	st	X+, r0
     186:	a8 32       	cpi	r26, 0x28	; 40
     188:	b1 07       	cpc	r27, r17
     18a:	d9 f7       	brne	.-10     	; 0x182 <__do_copy_data+0x10>

0000018c <__do_clear_bss>:
     18c:	26 e1       	ldi	r18, 0x16	; 22
     18e:	a8 e2       	ldi	r26, 0x28	; 40
     190:	b4 e0       	ldi	r27, 0x04	; 4
     192:	01 c0       	rjmp	.+2      	; 0x196 <.do_clear_bss_start>

00000194 <.do_clear_bss_loop>:
     194:	1d 92       	st	X+, r1

00000196 <.do_clear_bss_start>:
     196:	ad 3b       	cpi	r26, 0xBD	; 189
     198:	b2 07       	cpc	r27, r18
     19a:	e1 f7       	brne	.-8      	; 0x194 <.do_clear_bss_loop>
     19c:	98 d0       	rcall	.+304    	; 0x2ce <main>
     19e:	0c 94 1a 0f 	jmp	0x1e34	; 0x1e34 <_exit>

000001a2 <__bad_interrupt>:
     1a2:	2e cf       	rjmp	.-420    	; 0x0 <__vectors>

000001a4 <system_tick>:
     1a4:	8f 93       	push	r24
     1a6:	8f b7       	in	r24, 0x3f	; 63
     1a8:	8f 93       	push	r24
     1aa:	f8 94       	cli
     1ac:	80 91 b9 16 	lds	r24, 0x16B9	; 0x8016b9 <__system_time>
     1b0:	8f 5f       	subi	r24, 0xFF	; 255
     1b2:	80 93 b9 16 	sts	0x16B9, r24	; 0x8016b9 <__system_time>
     1b6:	80 91 ba 16 	lds	r24, 0x16BA	; 0x8016ba <__system_time+0x1>
     1ba:	8f 4f       	sbci	r24, 0xFF	; 255
     1bc:	80 93 ba 16 	sts	0x16BA, r24	; 0x8016ba <__system_time+0x1>
     1c0:	80 91 bb 16 	lds	r24, 0x16BB	; 0x8016bb <__system_time+0x2>
     1c4:	8f 4f       	sbci	r24, 0xFF	; 255
     1c6:	80 93 bb 16 	sts	0x16BB, r24	; 0x8016bb <__system_time+0x2>
     1ca:	80 91 bc 16 	lds	r24, 0x16BC	; 0x8016bc <__system_time+0x3>
     1ce:	8f 4f       	sbci	r24, 0xFF	; 255
     1d0:	80 93 bc 16 	sts	0x16BC, r24	; 0x8016bc <__system_time+0x3>
     1d4:	8f 91       	pop	r24
     1d6:	8f bf       	out	0x3f, r24	; 63
     1d8:	8f 91       	pop	r24
     1da:	08 95       	ret

000001dc <vReadSwitch>:



//Task para fazer ler o switch

void vReadSwitch(void *pvParameters) {
     1dc:	cf 93       	push	r28
     1de:	df 93       	push	r29
     1e0:	1f 92       	push	r1
     1e2:	cd b7       	in	r28, 0x3d	; 61
     1e4:	de b7       	in	r29, 0x3e	; 62
	uint8_t SW_Read, SW_Read_0, SW_Read_1, SW_State;
	SW_Read_0 = 0;
	SW_Read_1 = 0;
     1e6:	10 e0       	ldi	r17, 0x00	; 0

//Task para fazer ler o switch

void vReadSwitch(void *pvParameters) {
	uint8_t SW_Read, SW_Read_0, SW_Read_1, SW_State;
	SW_Read_0 = 0;
     1e8:	00 e0       	ldi	r16, 0x00	; 0
			SW_Read_1++;
		SW_Read_0 = 0;}
		
		if (SW_Read_1 >= DEBOUNCE_TIME){
			SW_Read_1 = DEBOUNCE_TIME +1;
		SW_State = 1;}
     1ea:	ff 24       	eor	r15, r15
     1ec:	f3 94       	inc	r15
	//const TickType_t xDelay = pdMS_TO_TICKS(5);
	//TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) {
		SW_Read = !(PINF & _BV(MySW)); //lê status da chave
		
		if (SW_Read == 0) {
     1ee:	79 9b       	sbis	0x0f, 1	; 15
     1f0:	06 c0       	rjmp	.+12     	; 0x1fe <vReadSwitch+0x22>
			SW_Read_0++;
     1f2:	0f 5f       	subi	r16, 0xFF	; 255
			SW_Read_1 = 0;
			if (SW_Read_0 >= DEBOUNCE_TIME){
     1f4:	0a 30       	cpi	r16, 0x0A	; 10
     1f6:	b8 f0       	brcs	.+46     	; 0x226 <vReadSwitch+0x4a>
				SW_Read_0 = DEBOUNCE_TIME +1;
			SW_State = 0;}
     1f8:	19 82       	std	Y+1, r1	; 0x01
		
		if (SW_Read == 0) {
			SW_Read_0++;
			SW_Read_1 = 0;
			if (SW_Read_0 >= DEBOUNCE_TIME){
				SW_Read_0 = DEBOUNCE_TIME +1;
     1fa:	0b e0       	ldi	r16, 0x0B	; 11
     1fc:	14 c0       	rjmp	.+40     	; 0x226 <vReadSwitch+0x4a>
			SW_State = 0;}
		}
		else {
			SW_Read_1++;
     1fe:	1f 5f       	subi	r17, 0xFF	; 255
		SW_Read_0 = 0;}
		
		if (SW_Read_1 >= DEBOUNCE_TIME){
     200:	1a 30       	cpi	r17, 0x0A	; 10
     202:	20 f0       	brcs	.+8      	; 0x20c <vReadSwitch+0x30>
			SW_Read_1 = DEBOUNCE_TIME +1;
		SW_State = 1;}
     204:	f9 82       	std	Y+1, r15	; 0x01
				SW_Read_0 = DEBOUNCE_TIME +1;
			SW_State = 0;}
		}
		else {
			SW_Read_1++;
		SW_Read_0 = 0;}
     206:	00 e0       	ldi	r16, 0x00	; 0
		
		if (SW_Read_1 >= DEBOUNCE_TIME){
			SW_Read_1 = DEBOUNCE_TIME +1;
     208:	1b e0       	ldi	r17, 0x0B	; 11
     20a:	01 c0       	rjmp	.+2      	; 0x20e <vReadSwitch+0x32>
				SW_Read_0 = DEBOUNCE_TIME +1;
			SW_State = 0;}
		}
		else {
			SW_Read_1++;
		SW_Read_0 = 0;}
     20c:	00 e0       	ldi	r16, 0x00	; 0
		
		if (SW_Read_1 >= DEBOUNCE_TIME){
			SW_Read_1 = DEBOUNCE_TIME +1;
		SW_State = 1;}
		xQueueOverwrite(MyQ, &SW_State);
     20e:	22 e0       	ldi	r18, 0x02	; 2
     210:	40 e0       	ldi	r20, 0x00	; 0
     212:	50 e0       	ldi	r21, 0x00	; 0
     214:	be 01       	movw	r22, r28
     216:	6f 5f       	subi	r22, 0xFF	; 255
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	80 91 b3 16 	lds	r24, 0x16B3	; 0x8016b3 <MyQ>
     21e:	90 91 b4 16 	lds	r25, 0x16B4	; 0x8016b4 <MyQ+0x1>
     222:	50 d5       	rcall	.+2720   	; 0xcc4 <xQueueGenericSend>
		
		//vTaskDelayUntil(&xLastWakeTime, xDelay);
	}
     224:	e4 cf       	rjmp	.-56     	; 0x1ee <vReadSwitch+0x12>
		else {
			SW_Read_1++;
		SW_Read_0 = 0;}
		
		if (SW_Read_1 >= DEBOUNCE_TIME){
			SW_Read_1 = DEBOUNCE_TIME +1;
     226:	10 e0       	ldi	r17, 0x00	; 0
     228:	f2 cf       	rjmp	.-28     	; 0x20e <vReadSwitch+0x32>

0000022a <vBlinkRedLed>:
}

//Task para fazer o Led Vermelho Piscar

void vBlinkRedLed(void *pvParameters) // LED posição PB.7
{
     22a:	cf 93       	push	r28
     22c:	df 93       	push	r29
     22e:	00 d0       	rcall	.+0      	; 0x230 <vBlinkRedLed+0x6>
     230:	cd b7       	in	r28, 0x3d	; 61
     232:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_status=0;
     234:	19 82       	std	Y+1, r1	; 0x01
	
	// Estabelece a duração da task
	const TickType_t xDelay = pdMS_TO_TICKS(300);
	TickType_t xLastWakeTime = xTaskGetTickCount();
     236:	0e 94 02 0a 	call	0x1404	; 0x1404 <xTaskGetTickCount>
     23a:	9b 83       	std	Y+3, r25	; 0x03
     23c:	8a 83       	std	Y+2, r24	; 0x02
	for (;;) {
		xQueuePeek(MyQ, &sw_status, portMAX_DELAY);
     23e:	4f ef       	ldi	r20, 0xFF	; 255
     240:	5f ef       	ldi	r21, 0xFF	; 255
     242:	be 01       	movw	r22, r28
     244:	6f 5f       	subi	r22, 0xFF	; 255
     246:	7f 4f       	sbci	r23, 0xFF	; 255
     248:	80 91 b3 16 	lds	r24, 0x16B3	; 0x8016b3 <MyQ>
     24c:	90 91 b4 16 	lds	r25, 0x16B4	; 0x8016b4 <MyQ+0x1>
     250:	8c d6       	rcall	.+3352   	; 0xf6a <xQueuePeek>
		// Block until the next release time.
		if (sw_status) PINB |= _BV(MyLED);   //troca
     252:	89 81       	ldd	r24, Y+1	; 0x01
     254:	88 23       	and	r24, r24
     256:	11 f0       	breq	.+4      	; 0x25c <vBlinkRedLed+0x32>
     258:	1e 9a       	sbi	0x03, 6	; 3
     25a:	01 c0       	rjmp	.+2      	; 0x25e <vBlinkRedLed+0x34>
		else PORTB &= ~_BV(MyLED);  //apaga
     25c:	2e 98       	cbi	0x05, 6	; 5
		vTaskDelayUntil(&xLastWakeTime, xDelay);
     25e:	6c e3       	ldi	r22, 0x3C	; 60
     260:	70 e0       	ldi	r23, 0x00	; 0
     262:	ce 01       	movw	r24, r28
     264:	02 96       	adiw	r24, 0x02	; 2
     266:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vTaskDelayUntil>
	}
     26a:	e9 cf       	rjmp	.-46     	; 0x23e <vBlinkRedLed+0x14>

0000026c <vDisplay_String_Nokia>:
}


//Task para exibir uma mensagem no display Nokia
void vDisplay_String_Nokia(void *pvParameters){
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	00 d0       	rcall	.+0      	; 0x272 <vDisplay_String_Nokia+0x6>
     272:	cd b7       	in	r28, 0x3d	; 61
     274:	de b7       	in	r29, 0x3e	; 62
	uint8_t sw_status=0;
     276:	19 82       	std	Y+1, r1	; 0x01
	const TickType_t xDelay = pdMS_TO_TICKS(500);
	
	
	TickType_t xLastWakeTime = xTaskGetTickCount();
     278:	0e 94 02 0a 	call	0x1404	; 0x1404 <xTaskGetTickCount>
     27c:	9b 83       	std	Y+3, r25	; 0x03
     27e:	8a 83       	std	Y+2, r24	; 0x02
	for (;;) {
		// Block until the next release time.
		xQueuePeek(MyQ, &sw_status, portMAX_DELAY);
     280:	4f ef       	ldi	r20, 0xFF	; 255
     282:	5f ef       	ldi	r21, 0xFF	; 255
     284:	be 01       	movw	r22, r28
     286:	6f 5f       	subi	r22, 0xFF	; 255
     288:	7f 4f       	sbci	r23, 0xFF	; 255
     28a:	80 91 b3 16 	lds	r24, 0x16B3	; 0x8016b3 <MyQ>
     28e:	90 91 b4 16 	lds	r25, 0x16B4	; 0x8016b4 <MyQ+0x1>
     292:	6b d6       	rcall	.+3286   	; 0xf6a <xQueuePeek>
		lcd_setXY(0,0);
     294:	60 e0       	ldi	r22, 0x00	; 0
     296:	80 e0       	ldi	r24, 0x00	; 0
     298:	ac d0       	rcall	.+344    	; 0x3f2 <lcd_setXY>
		N5110_Data("          ");
     29a:	82 e0       	ldi	r24, 0x02	; 2
     29c:	92 e0       	ldi	r25, 0x02	; 2
     29e:	4f d0       	rcall	.+158    	; 0x33e <N5110_Data>
		if (sw_status) {
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	88 23       	and	r24, r24
			lcd_setXY(0,0);
     2a4:	39 f0       	breq	.+14     	; 0x2b4 <vDisplay_String_Nokia+0x48>
     2a6:	60 e0       	ldi	r22, 0x00	; 0
     2a8:	80 e0       	ldi	r24, 0x00	; 0
			N5110_Data("SW pressed ");
     2aa:	a3 d0       	rcall	.+326    	; 0x3f2 <lcd_setXY>
     2ac:	8d e0       	ldi	r24, 0x0D	; 13
     2ae:	92 e0       	ldi	r25, 0x02	; 2
     2b0:	46 d0       	rcall	.+140    	; 0x33e <N5110_Data>
			}
		else {
			lcd_setXY(0,0);
     2b2:	06 c0       	rjmp	.+12     	; 0x2c0 <vDisplay_String_Nokia+0x54>
     2b4:	60 e0       	ldi	r22, 0x00	; 0
     2b6:	80 e0       	ldi	r24, 0x00	; 0
			N5110_Data("SW free ");}
     2b8:	9c d0       	rcall	.+312    	; 0x3f2 <lcd_setXY>
     2ba:	89 e1       	ldi	r24, 0x19	; 25
     2bc:	92 e0       	ldi	r25, 0x02	; 2
     2be:	3f d0       	rcall	.+126    	; 0x33e <N5110_Data>
		vTaskDelayUntil(&xLastWakeTime, xDelay);
     2c0:	62 e2       	ldi	r22, 0x22	; 34
     2c2:	70 e0       	ldi	r23, 0x00	; 0
     2c4:	ce 01       	movw	r24, r28
     2c6:	02 96       	adiw	r24, 0x02	; 2
     2c8:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vTaskDelayUntil>
		
	}
     2cc:	d9 cf       	rjmp	.-78     	; 0x280 <vDisplay_String_Nokia+0x14>

000002ce <main>:
	
	
	/*configura os pinos do LED e do SW */
	
	/* inicializa o LED */
DDRB |= _BV(MyLED); // Pin B7 is OUTPUT
     2ce:	26 9a       	sbi	0x04, 6	; 4

/* inicializa as portas */
DDRF &= ~_BV(MySW);  //Pin F1 is INPUT
     2d0:	81 98       	cbi	0x10, 1	; 16
PORTF |= _BV(MySW);  // Pin F1 with pull-up resistor
     2d2:	89 9a       	sbi	0x11, 1	; 17
	
		
	/*Inicializa módulo SPI e o módulo Nokia5110 */
	SPI_Init();
     2d4:	9b d0       	rcall	.+310    	; 0x40c <SPI_Init>
	N5110_init();
     2d6:	7f d0       	rcall	.+254    	; 0x3d6 <N5110_init>
     2d8:	40 e0       	ldi	r20, 0x00	; 0
		
	/* cria a fila para receber o dado do botão */
	MyQ = xQueueCreate(1,sizeof(uint8_t));	 //cria uma fila para um dado do tipo uint32_t
     2da:	61 e0       	ldi	r22, 0x01	; 1
     2dc:	81 e0       	ldi	r24, 0x01	; 1
     2de:	c8 d4       	rcall	.+2448   	; 0xc70 <xQueueGenericCreate>
     2e0:	90 93 b4 16 	sts	0x16B4, r25	; 0x8016b4 <MyQ+0x1>
     2e4:	80 93 b3 16 	sts	0x16B3, r24	; 0x8016b3 <MyQ>
     2e8:	e1 2c       	mov	r14, r1
	{
		//não consegui criar a fila }
	}
	
	/* cria as tasks do FreeRTOS */
	xTaskCreate(vReadSwitch, "SW status", 100, NULL, 1, NULL);
     2ea:	f1 2c       	mov	r15, r1
     2ec:	01 e0       	ldi	r16, 0x01	; 1
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	44 e6       	ldi	r20, 0x64	; 100
     2f4:	50 e0       	ldi	r21, 0x00	; 0
     2f6:	62 e2       	ldi	r22, 0x22	; 34
     2f8:	72 e0       	ldi	r23, 0x02	; 2
     2fa:	8e ee       	ldi	r24, 0xEE	; 238
     2fc:	90 e0       	ldi	r25, 0x00	; 0
     2fe:	4c d7       	rcall	.+3736   	; 0x1198 <xTaskCreate>
     300:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vBlinkRedLed, "LED", 100, NULL, 1, NULL);
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	44 e6       	ldi	r20, 0x64	; 100
     306:	50 e0       	ldi	r21, 0x00	; 0
     308:	6c e2       	ldi	r22, 0x2C	; 44
     30a:	72 e0       	ldi	r23, 0x02	; 2
     30c:	85 e1       	ldi	r24, 0x15	; 21
     30e:	91 e0       	ldi	r25, 0x01	; 1
     310:	43 d7       	rcall	.+3718   	; 0x1198 <xTaskCreate>
     312:	20 e0       	ldi	r18, 0x00	; 0
	xTaskCreate(vDisplay_String_Nokia, "Nokia 5110", 100, NULL, 1, NULL);
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	44 e6       	ldi	r20, 0x64	; 100
     318:	50 e0       	ldi	r21, 0x00	; 0
     31a:	60 e3       	ldi	r22, 0x30	; 48
     31c:	72 e0       	ldi	r23, 0x02	; 2
     31e:	86 e3       	ldi	r24, 0x36	; 54
     320:	91 e0       	ldi	r25, 0x01	; 1
     322:	3a d7       	rcall	.+3700   	; 0x1198 <xTaskCreate>
     324:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <vTaskStartScheduler>
	
	// Startup of the FreeRTOS scheduler. The program should block here.
	vTaskStartScheduler();
     328:	ff cf       	rjmp	.-2      	; 0x328 <main+0x5a>

0000032a <N5110_Cmnd>:
	,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e ->
	,{0x78, 0x46, 0x41, 0x46, 0x78} // 7f <-
};

void N5110_Cmnd(char DATA)
{
     32a:	cf 93       	push	r28
     32c:	c8 2f       	mov	r28, r24
	PORTB &= ~(1<<DC);				/* make DC pin to logic zero for command operation */
     32e:	2c 98       	cbi	0x05, 4	; 5
	SPI_SS_Enable();				/* enable SS pin to slave selection */
     330:	69 d0       	rcall	.+210    	; 0x404 <SPI_SS_Enable>
	SPI_Write(DATA);				/* send data on data register */
     332:	8c 2f       	mov	r24, r28
     334:	73 d0       	rcall	.+230    	; 0x41c <SPI_Write>
	PORTB |= (1<<DC);				/* make DC pin to logic high for data operation */
     336:	2c 9a       	sbi	0x05, 4	; 5
	SPI_SS_Disable();
     338:	67 d0       	rcall	.+206    	; 0x408 <SPI_SS_Disable>
     33a:	cf 91       	pop	r28
}
     33c:	08 95       	ret

0000033e <N5110_Data>:
     33e:	ef 92       	push	r14

void N5110_Data(char *DATA)
{
     340:	ff 92       	push	r15
     342:	0f 93       	push	r16
     344:	1f 93       	push	r17
     346:	cf 93       	push	r28
     348:	df 93       	push	r29
     34a:	8c 01       	movw	r16, r24
	PORTB |= (1<<DC);									/* make DC pin to logic high for data operation */
     34c:	2c 9a       	sbi	0x05, 4	; 5
	SPI_SS_Enable();									/* enable SS pin to slave selection */
     34e:	5a d0       	rcall	.+180    	; 0x404 <SPI_SS_Enable>
	int lenan = strlen(DATA);							/* measure the length of data */
     350:	f8 01       	movw	r30, r16
     352:	01 90       	ld	r0, Z+
     354:	00 20       	and	r0, r0
     356:	e9 f7       	brne	.-6      	; 0x352 <N5110_Data+0x14>
     358:	31 97       	sbiw	r30, 0x01	; 1
     35a:	e0 1b       	sub	r30, r16
     35c:	f1 0b       	sbc	r31, r17
	for (int g=0; g<lenan; g++)
     35e:	1e 16       	cp	r1, r30
     360:	1f 06       	cpc	r1, r31
     362:	2c f5       	brge	.+74     	; 0x3ae <N5110_Data+0x70>
     364:	e8 01       	movw	r28, r16
     366:	0e 0f       	add	r16, r30
     368:	1f 1f       	adc	r17, r31
     36a:	1e c0       	rjmp	.+60     	; 0x3a8 <N5110_Data+0x6a>
	{
		for (int index=0; index<5; index++)
		{
			SPI_Write(ASCII[DATA[g] - 0x20][index]);	/* send the data on data register */
     36c:	28 81       	ld	r18, Y
     36e:	30 e0       	ldi	r19, 0x00	; 0
     370:	20 52       	subi	r18, 0x20	; 32
     372:	31 09       	sbc	r19, r1
     374:	f9 01       	movw	r30, r18
     376:	ee 0f       	add	r30, r30
     378:	ff 1f       	adc	r31, r31
     37a:	ee 0f       	add	r30, r30
     37c:	ff 1f       	adc	r31, r31
     37e:	e2 0f       	add	r30, r18
     380:	f3 1f       	adc	r31, r19
     382:	e5 5c       	subi	r30, 0xC5	; 197
     384:	fd 4f       	sbci	r31, 0xFD	; 253
     386:	ee 0d       	add	r30, r14
     388:	ff 1d       	adc	r31, r15
     38a:	80 81       	ld	r24, Z
     38c:	47 d0       	rcall	.+142    	; 0x41c <SPI_Write>
	PORTB |= (1<<DC);									/* make DC pin to logic high for data operation */
	SPI_SS_Enable();									/* enable SS pin to slave selection */
	int lenan = strlen(DATA);							/* measure the length of data */
	for (int g=0; g<lenan; g++)
	{
		for (int index=0; index<5; index++)
     38e:	8f ef       	ldi	r24, 0xFF	; 255
     390:	e8 1a       	sub	r14, r24
     392:	f8 0a       	sbc	r15, r24
     394:	85 e0       	ldi	r24, 0x05	; 5
     396:	e8 16       	cp	r14, r24
     398:	f1 04       	cpc	r15, r1
		{
			SPI_Write(ASCII[DATA[g] - 0x20][index]);	/* send the data on data register */
		}
		SPI_Write(0x00);
     39a:	41 f7       	brne	.-48     	; 0x36c <N5110_Data+0x2e>
     39c:	80 e0       	ldi	r24, 0x00	; 0
     39e:	3e d0       	rcall	.+124    	; 0x41c <SPI_Write>
     3a0:	21 96       	adiw	r28, 0x01	; 1
void N5110_Data(char *DATA)
{
	PORTB |= (1<<DC);									/* make DC pin to logic high for data operation */
	SPI_SS_Enable();									/* enable SS pin to slave selection */
	int lenan = strlen(DATA);							/* measure the length of data */
	for (int g=0; g<lenan; g++)
     3a2:	0c 17       	cp	r16, r28
     3a4:	1d 07       	cpc	r17, r29
     3a6:	19 f0       	breq	.+6      	; 0x3ae <N5110_Data+0x70>
	PORTB |= (1<<DC);				/* make DC pin to logic high for data operation */
	SPI_SS_Disable();
}

void N5110_Data(char *DATA)
{
     3a8:	e1 2c       	mov	r14, r1
     3aa:	f1 2c       	mov	r15, r1
		{
			SPI_Write(ASCII[DATA[g] - 0x20][index]);	/* send the data on data register */
		}
		SPI_Write(0x00);
	}
	SPI_SS_Disable();
     3ac:	df cf       	rjmp	.-66     	; 0x36c <N5110_Data+0x2e>
     3ae:	2c d0       	rcall	.+88     	; 0x408 <SPI_SS_Disable>
}
     3b0:	df 91       	pop	r29
     3b2:	cf 91       	pop	r28
     3b4:	1f 91       	pop	r17
     3b6:	0f 91       	pop	r16
     3b8:	ff 90       	pop	r15
     3ba:	ef 90       	pop	r14
     3bc:	08 95       	ret

000003be <N5110_Reset>:

void N5110_Reset(void)					/* reset the Display at the beginning of initialization */
{
	PORTB &= ~(1<<RST);
     3be:	2d 98       	cbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3c0:	2f ef       	ldi	r18, 0xFF	; 255
     3c2:	81 ee       	ldi	r24, 0xE1	; 225
     3c4:	94 e0       	ldi	r25, 0x04	; 4
     3c6:	21 50       	subi	r18, 0x01	; 1
     3c8:	80 40       	sbci	r24, 0x00	; 0
     3ca:	90 40       	sbci	r25, 0x00	; 0
     3cc:	e1 f7       	brne	.-8      	; 0x3c6 <N5110_Reset+0x8>
     3ce:	00 c0       	rjmp	.+0      	; 0x3d0 <N5110_Reset+0x12>
     3d0:	00 00       	nop
	_delay_ms(100);
	PORTB |= (1<<RST);
     3d2:	2d 9a       	sbi	0x05, 5	; 5
     3d4:	08 95       	ret

000003d6 <N5110_init>:
}

void N5110_init(void)
{
	N5110_Reset();					/* reset the display */
     3d6:	f3 df       	rcall	.-26     	; 0x3be <N5110_Reset>
	N5110_Cmnd(0x21);				/* command set in addition mode */
     3d8:	81 e2       	ldi	r24, 0x21	; 33
     3da:	a7 df       	rcall	.-178    	; 0x32a <N5110_Cmnd>
	N5110_Cmnd(0xC0);				/* set the voltage by sending C0 means VOP = 5V */
     3dc:	80 ec       	ldi	r24, 0xC0	; 192
     3de:	a5 df       	rcall	.-182    	; 0x32a <N5110_Cmnd>
	N5110_Cmnd(0x07);				/* set the temp. coefficient to 3 */
     3e0:	87 e0       	ldi	r24, 0x07	; 7
     3e2:	a3 df       	rcall	.-186    	; 0x32a <N5110_Cmnd>
	N5110_Cmnd(0x13);				/* set value of Voltage Bias System */
     3e4:	83 e1       	ldi	r24, 0x13	; 19
     3e6:	a1 df       	rcall	.-190    	; 0x32a <N5110_Cmnd>
	N5110_Cmnd(0x20);				/* command set in basic mode */
     3e8:	80 e2       	ldi	r24, 0x20	; 32
     3ea:	9f df       	rcall	.-194    	; 0x32a <N5110_Cmnd>
     3ec:	8c e0       	ldi	r24, 0x0C	; 12
	N5110_Cmnd(0x0C);				/* display result in normal mode */
     3ee:	9d cf       	rjmp	.-198    	; 0x32a <N5110_Cmnd>
     3f0:	08 95       	ret

000003f2 <lcd_setXY>:
     3f2:	cf 93       	push	r28
     3f4:	c6 2f       	mov	r28, r22
}

void lcd_setXY(char x, char y)		/* set the column and row */
{
	N5110_Cmnd(0x80|x);  //set coluna (0 a 83)
     3f6:	80 68       	ori	r24, 0x80	; 128
     3f8:	98 df       	rcall	.-208    	; 0x32a <N5110_Cmnd>
	N5110_Cmnd(0x40|y);  //set linha (0 a 5)
     3fa:	8c 2f       	mov	r24, r28
     3fc:	80 64       	ori	r24, 0x40	; 64
     3fe:	95 df       	rcall	.-214    	; 0x32a <N5110_Cmnd>
}
     400:	cf 91       	pop	r28
     402:	08 95       	ret

00000404 <SPI_SS_Enable>:
char SPI_Read(void)
{
	SPDR = 0xFF;
	while(!(SPSR & (1<<SPIF)));										/* wait here while SPIF flag set */
	return(SPDR);													/* Return the SPDR value */
}
     404:	28 98       	cbi	0x05, 0	; 5
     406:	08 95       	ret

00000408 <SPI_SS_Disable>:
     408:	28 9a       	sbi	0x05, 0	; 5
     40a:	08 95       	ret

0000040c <SPI_Init>:
     40c:	87 e3       	ldi	r24, 0x37	; 55
     40e:	84 b9       	out	0x04, r24	; 4
     410:	2d 9a       	sbi	0x05, 5	; 5
     412:	23 98       	cbi	0x04, 3	; 4
     414:	28 9a       	sbi	0x05, 0	; 5
     416:	81 e5       	ldi	r24, 0x51	; 81
     418:	8c bd       	out	0x2c, r24	; 44
     41a:	08 95       	ret

0000041c <SPI_Write>:

void SPI_Write(char write_data)										
{
	SPDR = write_data;													
     41c:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));										/* wait here while SPIF flag set */
     41e:	0d b4       	in	r0, 0x2d	; 45
     420:	07 fe       	sbrs	r0, 7
     422:	fd cf       	rjmp	.-6      	; 0x41e <SPI_Write+0x2>
}
     424:	08 95       	ret

00000426 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     426:	0f 93       	push	r16
     428:	1f 93       	push	r17
     42a:	cf 93       	push	r28
     42c:	df 93       	push	r29
     42e:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     430:	e3 d7       	rcall	.+4038   	; 0x13f8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     432:	80 91 28 04 	lds	r24, 0x0428	; 0x800428 <__data_end>
     436:	81 11       	cpse	r24, r1
     438:	1d c0       	rjmp	.+58     	; 0x474 <pvPortMalloc+0x4e>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     43a:	ed e2       	ldi	r30, 0x2D	; 45
     43c:	f4 e0       	ldi	r31, 0x04	; 4
     43e:	82 e3       	ldi	r24, 0x32	; 50
     440:	94 e0       	ldi	r25, 0x04	; 4
     442:	91 83       	std	Z+1, r25	; 0x01
     444:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     446:	13 82       	std	Z+3, r1	; 0x03
     448:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     44a:	e9 e2       	ldi	r30, 0x29	; 41
     44c:	f4 e0       	ldi	r31, 0x04	; 4
     44e:	8f ef       	ldi	r24, 0xFF	; 255
     450:	91 e1       	ldi	r25, 0x11	; 17
     452:	93 83       	std	Z+3, r25	; 0x03
     454:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     456:	11 82       	std	Z+1, r1	; 0x01
     458:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     45a:	a1 e3       	ldi	r26, 0x31	; 49
     45c:	b4 e0       	ldi	r27, 0x04	; 4
     45e:	14 96       	adiw	r26, 0x04	; 4
     460:	9c 93       	st	X, r25
     462:	8e 93       	st	-X, r24
     464:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     466:	12 96       	adiw	r26, 0x02	; 2
     468:	fc 93       	st	X, r31
     46a:	ee 93       	st	-X, r30
     46c:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	80 93 28 04 	sts	0x0428, r24	; 0x800428 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     474:	20 97       	sbiw	r28, 0x00	; 0
     476:	09 f4       	brne	.+2      	; 0x47a <pvPortMalloc+0x54>
     478:	6a c0       	rjmp	.+212    	; 0x54e <pvPortMalloc+0x128>
		{
			xWantedSize += heapSTRUCT_SIZE;
     47a:	9e 01       	movw	r18, r28
     47c:	2c 5f       	subi	r18, 0xFC	; 252
     47e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     480:	23 96       	adiw	r28, 0x03	; 3
     482:	ce 3f       	cpi	r28, 0xFE	; 254
     484:	d1 41       	sbci	r29, 0x11	; 17
     486:	08 f0       	brcs	.+2      	; 0x48a <pvPortMalloc+0x64>
     488:	5f c0       	rjmp	.+190    	; 0x548 <pvPortMalloc+0x122>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     48a:	e0 91 2d 04 	lds	r30, 0x042D	; 0x80042d <xStart>
     48e:	f0 91 2e 04 	lds	r31, 0x042E	; 0x80042e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     492:	ad e2       	ldi	r26, 0x2D	; 45
     494:	b4 e0       	ldi	r27, 0x04	; 4
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     496:	02 c0       	rjmp	.+4      	; 0x49c <pvPortMalloc+0x76>
     498:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     49a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     49c:	82 81       	ldd	r24, Z+2	; 0x02
     49e:	93 81       	ldd	r25, Z+3	; 0x03
     4a0:	82 17       	cp	r24, r18
     4a2:	93 07       	cpc	r25, r19
     4a4:	20 f4       	brcc	.+8      	; 0x4ae <pvPortMalloc+0x88>
     4a6:	80 81       	ld	r24, Z
     4a8:	91 81       	ldd	r25, Z+1	; 0x01
     4aa:	00 97       	sbiw	r24, 0x00	; 0
     4ac:	a9 f7       	brne	.-22     	; 0x498 <pvPortMalloc+0x72>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     4ae:	c4 e0       	ldi	r28, 0x04	; 4
     4b0:	e9 32       	cpi	r30, 0x29	; 41
     4b2:	fc 07       	cpc	r31, r28
     4b4:	09 f4       	brne	.+2      	; 0x4b8 <pvPortMalloc+0x92>
     4b6:	48 c0       	rjmp	.+144    	; 0x548 <pvPortMalloc+0x122>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     4b8:	cd 91       	ld	r28, X+
     4ba:	dc 91       	ld	r29, X
     4bc:	11 97       	sbiw	r26, 0x01	; 1
     4be:	8e 01       	movw	r16, r28
     4c0:	0c 5f       	subi	r16, 0xFC	; 252
     4c2:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     4c4:	80 81       	ld	r24, Z
     4c6:	91 81       	ldd	r25, Z+1	; 0x01
     4c8:	8d 93       	st	X+, r24
     4ca:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     4cc:	82 81       	ldd	r24, Z+2	; 0x02
     4ce:	93 81       	ldd	r25, Z+3	; 0x03
     4d0:	82 1b       	sub	r24, r18
     4d2:	93 0b       	sbc	r25, r19
     4d4:	89 30       	cpi	r24, 0x09	; 9
     4d6:	91 05       	cpc	r25, r1
     4d8:	10 f1       	brcs	.+68     	; 0x51e <pvPortMalloc+0xf8>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     4da:	bf 01       	movw	r22, r30
     4dc:	62 0f       	add	r22, r18
     4de:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     4e0:	db 01       	movw	r26, r22
     4e2:	13 96       	adiw	r26, 0x03	; 3
     4e4:	9c 93       	st	X, r25
     4e6:	8e 93       	st	-X, r24
     4e8:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     4ea:	33 83       	std	Z+3, r19	; 0x03
     4ec:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     4ee:	12 96       	adiw	r26, 0x02	; 2
     4f0:	4d 91       	ld	r20, X+
     4f2:	5c 91       	ld	r21, X
     4f4:	13 97       	sbiw	r26, 0x03	; 3
     4f6:	8d e2       	ldi	r24, 0x2D	; 45
     4f8:	94 e0       	ldi	r25, 0x04	; 4
     4fa:	01 c0       	rjmp	.+2      	; 0x4fe <pvPortMalloc+0xd8>
     4fc:	cd 01       	movw	r24, r26
     4fe:	ec 01       	movw	r28, r24
     500:	a8 81       	ld	r26, Y
     502:	b9 81       	ldd	r27, Y+1	; 0x01
     504:	12 96       	adiw	r26, 0x02	; 2
     506:	2d 91       	ld	r18, X+
     508:	3c 91       	ld	r19, X
     50a:	13 97       	sbiw	r26, 0x03	; 3
     50c:	24 17       	cp	r18, r20
     50e:	35 07       	cpc	r19, r21
     510:	a8 f3       	brcs	.-22     	; 0x4fc <pvPortMalloc+0xd6>
     512:	eb 01       	movw	r28, r22
     514:	b9 83       	std	Y+1, r27	; 0x01
     516:	a8 83       	st	Y, r26
     518:	dc 01       	movw	r26, r24
     51a:	6d 93       	st	X+, r22
     51c:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     51e:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
     522:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
     526:	22 81       	ldd	r18, Z+2	; 0x02
     528:	33 81       	ldd	r19, Z+3	; 0x03
     52a:	82 1b       	sub	r24, r18
     52c:	93 0b       	sbc	r25, r19
     52e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
     532:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     536:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     53a:	01 15       	cp	r16, r1
     53c:	11 05       	cpc	r17, r1
     53e:	51 f4       	brne	.+20     	; 0x554 <pvPortMalloc+0x12e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     540:	59 d0       	rcall	.+178    	; 0x5f4 <vApplicationMallocFailedHook>
     542:	00 e0       	ldi	r16, 0x00	; 0
     544:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
     546:	06 c0       	rjmp	.+12     	; 0x554 <pvPortMalloc+0x12e>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     548:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
     54c:	f9 cf       	rjmp	.-14     	; 0x540 <pvPortMalloc+0x11a>
     54e:	0e 94 c3 0a 	call	0x1586	; 0x1586 <xTaskResumeAll>
     552:	f6 cf       	rjmp	.-20     	; 0x540 <pvPortMalloc+0x11a>
		}
	}
	#endif

	return pvReturn;
}
     554:	c8 01       	movw	r24, r16
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	1f 91       	pop	r17
     55c:	0f 91       	pop	r16
     55e:	08 95       	ret

00000560 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     560:	0f 93       	push	r16
     562:	1f 93       	push	r17
     564:	cf 93       	push	r28
     566:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     568:	00 97       	sbiw	r24, 0x00	; 0
     56a:	31 f1       	breq	.+76     	; 0x5b8 <vPortFree+0x58>
     56c:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     56e:	8c 01       	movw	r16, r24
     570:	04 50       	subi	r16, 0x04	; 4
     572:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     574:	41 d7       	rcall	.+3714   	; 0x13f8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     576:	f8 01       	movw	r30, r16
     578:	42 81       	ldd	r20, Z+2	; 0x02
     57a:	53 81       	ldd	r21, Z+3	; 0x03
     57c:	ad e2       	ldi	r26, 0x2D	; 45
     57e:	b4 e0       	ldi	r27, 0x04	; 4
     580:	01 c0       	rjmp	.+2      	; 0x584 <vPortFree+0x24>
     582:	df 01       	movw	r26, r30
     584:	ed 91       	ld	r30, X+
     586:	fc 91       	ld	r31, X
     588:	11 97       	sbiw	r26, 0x01	; 1
     58a:	22 81       	ldd	r18, Z+2	; 0x02
     58c:	33 81       	ldd	r19, Z+3	; 0x03
     58e:	24 17       	cp	r18, r20
     590:	35 07       	cpc	r19, r21
     592:	b8 f3       	brcs	.-18     	; 0x582 <vPortFree+0x22>
     594:	24 97       	sbiw	r28, 0x04	; 4
     596:	f9 83       	std	Y+1, r31	; 0x01
     598:	e8 83       	st	Y, r30
     59a:	0d 93       	st	X+, r16
     59c:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     59e:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
     5a2:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
     5a6:	8a 81       	ldd	r24, Y+2	; 0x02
     5a8:	9b 81       	ldd	r25, Y+3	; 0x03
     5aa:	82 0f       	add	r24, r18
     5ac:	93 1f       	adc	r25, r19
     5ae:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
     5b2:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     5b6:	e7 d7       	rcall	.+4046   	; 0x1586 <xTaskResumeAll>
	}
}
     5b8:	df 91       	pop	r29
     5ba:	cf 91       	pop	r28
     5bc:	1f 91       	pop	r17
     5be:	0f 91       	pop	r16
     5c0:	08 95       	ret

000005c2 <vApplicationIdleHook>:
	// The corresponding PIN Register bit will always read as zero when this bit is set. When an
	// analogue signal is applied to the ADC7..0 pin and the digital input from this pin is not needed, this
	// bit should be written logic one to reduce power consumption in the digital input buffer.

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Arduino Mega with 2560
	DIDR0 = 0xFF;
     5c2:	8f ef       	ldi	r24, 0xFF	; 255
     5c4:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x70007e>
	DIDR2 = 0xFF;
     5c8:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x70007d>
	// When the ACD bit is written logic one, the power to the Analogue Comparator is switched off.
	// This bit can be set at any time to turn off the Analogue Comparator.
	// This will reduce power consumption in Active and Idle mode.
	// When changing the ACD bit, the Analogue Comparator Interrupt must be disabled by clearing the ACIE bit in ACSR.
	// Otherwise an interrupt can occur when the ACD bit is changed.
	ACSR &= ~_BV(ACIE);
     5cc:	80 b7       	in	r24, 0x30	; 48
     5ce:	87 7f       	andi	r24, 0xF7	; 247
     5d0:	80 bf       	out	0x30, r24	; 48
	ACSR |=  _BV(ACD);
     5d2:	80 b7       	in	r24, 0x30	; 48
     5d4:	80 68       	ori	r24, 0x80	; 128
     5d6:	80 bf       	out	0x30, r24	; 48
	// SLEEP_MODE_PWR_DOWN     _BV(SM1)
	// SLEEP_MODE_PWR_SAVE     (_BV(SM0) | _BV(SM1))
	// SLEEP_MODE_STANDBY      (_BV(SM1) | _BV(SM2))
	// SLEEP_MODE_EXT_STANDBY  (_BV(SM0) | _BV(SM1) | _BV(SM2))

	set_sleep_mode( SLEEP_MODE_IDLE );
     5d8:	83 b7       	in	r24, 0x33	; 51
     5da:	81 7f       	andi	r24, 0xF1	; 241
     5dc:	83 bf       	out	0x33, r24	; 51

	portENTER_CRITICAL();
     5de:	0f b6       	in	r0, 0x3f	; 63
     5e0:	f8 94       	cli
     5e2:	0f 92       	push	r0
	sleep_enable();
     5e4:	83 b7       	in	r24, 0x33	; 51
     5e6:	81 60       	ori	r24, 0x01	; 1
     5e8:	83 bf       	out	0x33, r24	; 51

#if defined(BODS) && defined(BODSE) // only if there is support to disable the BOD.
	sleep_bod_disable();
#endif

	portEXIT_CRITICAL();
     5ea:	0f 90       	pop	r0
     5ec:	0f be       	out	0x3f, r0	; 63
	sleep_cpu();		// good night.
     5ee:	88 95       	sleep

	sleep_reset();		// reset the sleep_mode() faster than sleep_disable();
     5f0:	13 be       	out	0x33, r1	; 51
     5f2:	08 95       	ret

000005f4 <vApplicationMallocFailedHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__) // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
     5f4:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     5f6:	2f 9a       	sbi	0x05, 7	; 5
     5f8:	2f ef       	ldi	r18, 0xFF	; 255
     5fa:	80 e7       	ldi	r24, 0x70	; 112
     5fc:	92 e0       	ldi	r25, 0x02	; 2
     5fe:	21 50       	subi	r18, 0x01	; 1
     600:	80 40       	sbci	r24, 0x00	; 0
     602:	90 40       	sbci	r25, 0x00	; 0
     604:	e1 f7       	brne	.-8      	; 0x5fe <vApplicationMallocFailedHook+0xa>
     606:	00 c0       	rjmp	.+0      	; 0x608 <vApplicationMallocFailedHook+0x14>
     608:	00 00       	nop
	for(;;)
	{
		_delay_ms(50);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.
     60a:	1f 9a       	sbi	0x03, 7	; 3
     60c:	f5 cf       	rjmp	.-22     	; 0x5f8 <vApplicationMallocFailedHook+0x4>

0000060e <vApplicationStackOverflowHook>:
	   This routine will never return.
	   This routine is referenced in the task.c file of FreeRTOS as an extern.
	\*---------------------------------------------------------------------------*/

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
	DDRB  |= _BV(DDB7);
     60e:	27 9a       	sbi	0x04, 7	; 4
	PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.
     610:	2f 9a       	sbi	0x05, 7	; 5
     612:	2f ef       	ldi	r18, 0xFF	; 255
     614:	87 ea       	ldi	r24, 0xA7	; 167
     616:	91 e6       	ldi	r25, 0x61	; 97
     618:	21 50       	subi	r18, 0x01	; 1
     61a:	80 40       	sbci	r24, 0x00	; 0
     61c:	90 40       	sbci	r25, 0x00	; 0
     61e:	e1 f7       	brne	.-8      	; 0x618 <vApplicationStackOverflowHook+0xa>
     620:	00 c0       	rjmp	.+0      	; 0x622 <vApplicationStackOverflowHook+0x14>
     622:	00 00       	nop
	for(;;)
	{
		_delay_ms(2000);

#if defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)  // Arduino Mega with 2560
		PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.
     624:	1f 9a       	sbi	0x03, 7	; 3
     626:	f5 cf       	rjmp	.-22     	; 0x612 <vApplicationStackOverflowHook+0x4>

00000628 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     628:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     62a:	03 96       	adiw	r24, 0x03	; 3
     62c:	92 83       	std	Z+2, r25	; 0x02
     62e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     630:	2f ef       	ldi	r18, 0xFF	; 255
     632:	3f ef       	ldi	r19, 0xFF	; 255
     634:	34 83       	std	Z+4, r19	; 0x04
     636:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     638:	96 83       	std	Z+6, r25	; 0x06
     63a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     63c:	90 87       	std	Z+8, r25	; 0x08
     63e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     640:	10 82       	st	Z, r1
     642:	08 95       	ret

00000644 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     644:	fc 01       	movw	r30, r24
     646:	11 86       	std	Z+9, r1	; 0x09
     648:	10 86       	std	Z+8, r1	; 0x08
     64a:	08 95       	ret

0000064c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     64c:	cf 93       	push	r28
     64e:	df 93       	push	r29
     650:	9c 01       	movw	r18, r24
     652:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     654:	dc 01       	movw	r26, r24
     656:	11 96       	adiw	r26, 0x01	; 1
     658:	cd 91       	ld	r28, X+
     65a:	dc 91       	ld	r29, X
     65c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     65e:	d3 83       	std	Z+3, r29	; 0x03
     660:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     662:	8c 81       	ldd	r24, Y+4	; 0x04
     664:	9d 81       	ldd	r25, Y+5	; 0x05
     666:	95 83       	std	Z+5, r25	; 0x05
     668:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     66a:	8c 81       	ldd	r24, Y+4	; 0x04
     66c:	9d 81       	ldd	r25, Y+5	; 0x05
     66e:	dc 01       	movw	r26, r24
     670:	13 96       	adiw	r26, 0x03	; 3
     672:	7c 93       	st	X, r23
     674:	6e 93       	st	-X, r22
     676:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     678:	7d 83       	std	Y+5, r23	; 0x05
     67a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     67c:	31 87       	std	Z+9, r19	; 0x09
     67e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     680:	f9 01       	movw	r30, r18
     682:	80 81       	ld	r24, Z
     684:	8f 5f       	subi	r24, 0xFF	; 255
     686:	80 83       	st	Z, r24
}
     688:	df 91       	pop	r29
     68a:	cf 91       	pop	r28
     68c:	08 95       	ret

0000068e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     68e:	cf 93       	push	r28
     690:	df 93       	push	r29
     692:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     694:	48 81       	ld	r20, Y
     696:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     698:	4f 3f       	cpi	r20, 0xFF	; 255
     69a:	2f ef       	ldi	r18, 0xFF	; 255
     69c:	52 07       	cpc	r21, r18
     69e:	21 f4       	brne	.+8      	; 0x6a8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6a0:	fc 01       	movw	r30, r24
     6a2:	a7 81       	ldd	r26, Z+7	; 0x07
     6a4:	b0 85       	ldd	r27, Z+8	; 0x08
     6a6:	0d c0       	rjmp	.+26     	; 0x6c2 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6a8:	dc 01       	movw	r26, r24
     6aa:	13 96       	adiw	r26, 0x03	; 3
     6ac:	01 c0       	rjmp	.+2      	; 0x6b0 <vListInsert+0x22>
     6ae:	df 01       	movw	r26, r30
     6b0:	12 96       	adiw	r26, 0x02	; 2
     6b2:	ed 91       	ld	r30, X+
     6b4:	fc 91       	ld	r31, X
     6b6:	13 97       	sbiw	r26, 0x03	; 3
     6b8:	20 81       	ld	r18, Z
     6ba:	31 81       	ldd	r19, Z+1	; 0x01
     6bc:	42 17       	cp	r20, r18
     6be:	53 07       	cpc	r21, r19
     6c0:	b0 f7       	brcc	.-20     	; 0x6ae <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     6c2:	12 96       	adiw	r26, 0x02	; 2
     6c4:	ed 91       	ld	r30, X+
     6c6:	fc 91       	ld	r31, X
     6c8:	13 97       	sbiw	r26, 0x03	; 3
     6ca:	fb 83       	std	Y+3, r31	; 0x03
     6cc:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     6ce:	d5 83       	std	Z+5, r29	; 0x05
     6d0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     6d2:	bd 83       	std	Y+5, r27	; 0x05
     6d4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     6d6:	13 96       	adiw	r26, 0x03	; 3
     6d8:	dc 93       	st	X, r29
     6da:	ce 93       	st	-X, r28
     6dc:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6de:	99 87       	std	Y+9, r25	; 0x09
     6e0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     6e2:	fc 01       	movw	r30, r24
     6e4:	20 81       	ld	r18, Z
     6e6:	2f 5f       	subi	r18, 0xFF	; 255
     6e8:	20 83       	st	Z, r18
}
     6ea:	df 91       	pop	r29
     6ec:	cf 91       	pop	r28
     6ee:	08 95       	ret

000006f0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6f6:	a0 85       	ldd	r26, Z+8	; 0x08
     6f8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6fa:	c2 81       	ldd	r28, Z+2	; 0x02
     6fc:	d3 81       	ldd	r29, Z+3	; 0x03
     6fe:	84 81       	ldd	r24, Z+4	; 0x04
     700:	95 81       	ldd	r25, Z+5	; 0x05
     702:	9d 83       	std	Y+5, r25	; 0x05
     704:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     706:	c4 81       	ldd	r28, Z+4	; 0x04
     708:	d5 81       	ldd	r29, Z+5	; 0x05
     70a:	82 81       	ldd	r24, Z+2	; 0x02
     70c:	93 81       	ldd	r25, Z+3	; 0x03
     70e:	9b 83       	std	Y+3, r25	; 0x03
     710:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     712:	11 96       	adiw	r26, 0x01	; 1
     714:	8d 91       	ld	r24, X+
     716:	9c 91       	ld	r25, X
     718:	12 97       	sbiw	r26, 0x02	; 2
     71a:	e8 17       	cp	r30, r24
     71c:	f9 07       	cpc	r31, r25
     71e:	31 f4       	brne	.+12     	; 0x72c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     720:	84 81       	ldd	r24, Z+4	; 0x04
     722:	95 81       	ldd	r25, Z+5	; 0x05
     724:	12 96       	adiw	r26, 0x02	; 2
     726:	9c 93       	st	X, r25
     728:	8e 93       	st	-X, r24
     72a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     72c:	11 86       	std	Z+9, r1	; 0x09
     72e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     730:	8c 91       	ld	r24, X
     732:	81 50       	subi	r24, 0x01	; 1
     734:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     736:	8c 91       	ld	r24, X
}
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	08 95       	ret

0000073e <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
        portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
        ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
        portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
     73e:	31 e1       	ldi	r19, 0x11	; 17
     740:	fc 01       	movw	r30, r24
     742:	30 83       	st	Z, r19
     744:	31 97       	sbiw	r30, 0x01	; 1
     746:	22 e2       	ldi	r18, 0x22	; 34
     748:	20 83       	st	Z, r18
     74a:	31 97       	sbiw	r30, 0x01	; 1
     74c:	a3 e3       	ldi	r26, 0x33	; 51
     74e:	a0 83       	st	Z, r26
     750:	31 97       	sbiw	r30, 0x01	; 1
     752:	60 83       	st	Z, r22
     754:	31 97       	sbiw	r30, 0x01	; 1
     756:	70 83       	st	Z, r23
     758:	31 97       	sbiw	r30, 0x01	; 1
     75a:	10 82       	st	Z, r1
     75c:	31 97       	sbiw	r30, 0x01	; 1
     75e:	10 82       	st	Z, r1
     760:	31 97       	sbiw	r30, 0x01	; 1
     762:	60 e8       	ldi	r22, 0x80	; 128
     764:	60 83       	st	Z, r22
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	10 82       	st	Z, r1
     76a:	31 97       	sbiw	r30, 0x01	; 1
     76c:	10 82       	st	Z, r1
     76e:	31 97       	sbiw	r30, 0x01	; 1
     770:	10 82       	st	Z, r1
     772:	31 97       	sbiw	r30, 0x01	; 1
     774:	62 e0       	ldi	r22, 0x02	; 2
     776:	60 83       	st	Z, r22
     778:	31 97       	sbiw	r30, 0x01	; 1
     77a:	63 e0       	ldi	r22, 0x03	; 3
     77c:	60 83       	st	Z, r22
     77e:	31 97       	sbiw	r30, 0x01	; 1
     780:	64 e0       	ldi	r22, 0x04	; 4
     782:	60 83       	st	Z, r22
     784:	31 97       	sbiw	r30, 0x01	; 1
     786:	65 e0       	ldi	r22, 0x05	; 5
     788:	60 83       	st	Z, r22
     78a:	31 97       	sbiw	r30, 0x01	; 1
     78c:	66 e0       	ldi	r22, 0x06	; 6
     78e:	60 83       	st	Z, r22
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	67 e0       	ldi	r22, 0x07	; 7
     794:	60 83       	st	Z, r22
     796:	31 97       	sbiw	r30, 0x01	; 1
     798:	68 e0       	ldi	r22, 0x08	; 8
     79a:	60 83       	st	Z, r22
     79c:	31 97       	sbiw	r30, 0x01	; 1
     79e:	69 e0       	ldi	r22, 0x09	; 9
     7a0:	60 83       	st	Z, r22
     7a2:	31 97       	sbiw	r30, 0x01	; 1
     7a4:	60 e1       	ldi	r22, 0x10	; 16
     7a6:	60 83       	st	Z, r22
     7a8:	31 97       	sbiw	r30, 0x01	; 1
     7aa:	30 83       	st	Z, r19
     7ac:	31 97       	sbiw	r30, 0x01	; 1
     7ae:	32 e1       	ldi	r19, 0x12	; 18
     7b0:	30 83       	st	Z, r19
     7b2:	31 97       	sbiw	r30, 0x01	; 1
     7b4:	33 e1       	ldi	r19, 0x13	; 19
     7b6:	30 83       	st	Z, r19
     7b8:	31 97       	sbiw	r30, 0x01	; 1
     7ba:	34 e1       	ldi	r19, 0x14	; 20
     7bc:	30 83       	st	Z, r19
     7be:	31 97       	sbiw	r30, 0x01	; 1
     7c0:	35 e1       	ldi	r19, 0x15	; 21
     7c2:	30 83       	st	Z, r19
     7c4:	31 97       	sbiw	r30, 0x01	; 1
     7c6:	36 e1       	ldi	r19, 0x16	; 22
     7c8:	30 83       	st	Z, r19
     7ca:	31 97       	sbiw	r30, 0x01	; 1
     7cc:	37 e1       	ldi	r19, 0x17	; 23
     7ce:	30 83       	st	Z, r19
     7d0:	31 97       	sbiw	r30, 0x01	; 1
     7d2:	38 e1       	ldi	r19, 0x18	; 24
     7d4:	30 83       	st	Z, r19
     7d6:	31 97       	sbiw	r30, 0x01	; 1
     7d8:	39 e1       	ldi	r19, 0x19	; 25
     7da:	30 83       	st	Z, r19
     7dc:	31 97       	sbiw	r30, 0x01	; 1
     7de:	30 e2       	ldi	r19, 0x20	; 32
     7e0:	30 83       	st	Z, r19
     7e2:	31 97       	sbiw	r30, 0x01	; 1
     7e4:	31 e2       	ldi	r19, 0x21	; 33
     7e6:	30 83       	st	Z, r19
     7e8:	31 97       	sbiw	r30, 0x01	; 1
     7ea:	20 83       	st	Z, r18
     7ec:	31 97       	sbiw	r30, 0x01	; 1
     7ee:	23 e2       	ldi	r18, 0x23	; 35
     7f0:	20 83       	st	Z, r18
     7f2:	31 97       	sbiw	r30, 0x01	; 1
     7f4:	40 83       	st	Z, r20
     7f6:	31 97       	sbiw	r30, 0x01	; 1
     7f8:	50 83       	st	Z, r21
     7fa:	31 97       	sbiw	r30, 0x01	; 1
     7fc:	26 e2       	ldi	r18, 0x26	; 38
     7fe:	20 83       	st	Z, r18
     800:	31 97       	sbiw	r30, 0x01	; 1
     802:	27 e2       	ldi	r18, 0x27	; 39
     804:	20 83       	st	Z, r18
     806:	31 97       	sbiw	r30, 0x01	; 1
     808:	28 e2       	ldi	r18, 0x28	; 40
     80a:	20 83       	st	Z, r18
     80c:	31 97       	sbiw	r30, 0x01	; 1
     80e:	29 e2       	ldi	r18, 0x29	; 41
     810:	20 83       	st	Z, r18
     812:	31 97       	sbiw	r30, 0x01	; 1
     814:	20 e3       	ldi	r18, 0x30	; 48
     816:	20 83       	st	Z, r18
     818:	31 97       	sbiw	r30, 0x01	; 1
     81a:	21 e3       	ldi	r18, 0x31	; 49
     81c:	20 83       	st	Z, r18
     81e:	89 97       	sbiw	r24, 0x29	; 41
     820:	08 95       	ret

00000822 <xPortStartScheduler>:
     822:	88 ec       	ldi	r24, 0xC8	; 200
     824:	90 e0       	ldi	r25, 0x00	; 0
     826:	90 93 b6 16 	sts	0x16B6, r25	; 0x8016b6 <portTickRateHz+0x1>
     82a:	80 93 b5 16 	sts	0x16B5, r24	; 0x8016b5 <portTickRateHz>
     82e:	90 93 b8 16 	sts	0x16B8, r25	; 0x8016b8 <ticksRemainingInSec+0x1>
     832:	80 93 b7 16 	sts	0x16B7, r24	; 0x8016b7 <ticksRemainingInSec>
     836:	84 e0       	ldi	r24, 0x04	; 4
     838:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
     83c:	81 ee       	ldi	r24, 0xE1	; 225
     83e:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
     842:	8b e0       	ldi	r24, 0x0B	; 11
     844:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
     848:	e1 e7       	ldi	r30, 0x71	; 113
     84a:	f0 e0       	ldi	r31, 0x00	; 0
     84c:	80 81       	ld	r24, Z
     84e:	82 60       	ori	r24, 0x02	; 2
     850:	80 83       	st	Z, r24
     852:	a0 91 95 16 	lds	r26, 0x1695	; 0x801695 <pxCurrentTCB>
     856:	b0 91 96 16 	lds	r27, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
     85a:	cd 91       	ld	r28, X+
     85c:	cd bf       	out	0x3d, r28	; 61
     85e:	dd 91       	ld	r29, X+
     860:	de bf       	out	0x3e, r29	; 62
     862:	ff 91       	pop	r31
     864:	ef 91       	pop	r30
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	bf 91       	pop	r27
     86c:	af 91       	pop	r26
     86e:	9f 91       	pop	r25
     870:	8f 91       	pop	r24
     872:	7f 91       	pop	r23
     874:	6f 91       	pop	r22
     876:	5f 91       	pop	r21
     878:	4f 91       	pop	r20
     87a:	3f 91       	pop	r19
     87c:	2f 91       	pop	r18
     87e:	1f 91       	pop	r17
     880:	0f 91       	pop	r16
     882:	ff 90       	pop	r15
     884:	ef 90       	pop	r14
     886:	df 90       	pop	r13
     888:	cf 90       	pop	r12
     88a:	bf 90       	pop	r11
     88c:	af 90       	pop	r10
     88e:	9f 90       	pop	r9
     890:	8f 90       	pop	r8
     892:	7f 90       	pop	r7
     894:	6f 90       	pop	r6
     896:	5f 90       	pop	r5
     898:	4f 90       	pop	r4
     89a:	3f 90       	pop	r3
     89c:	2f 90       	pop	r2
     89e:	1f 90       	pop	r1
     8a0:	0f 90       	pop	r0
     8a2:	0c be       	out	0x3c, r0	; 60
     8a4:	0f 90       	pop	r0
     8a6:	0b be       	out	0x3b, r0	; 59
     8a8:	0f 90       	pop	r0
     8aa:	0f be       	out	0x3f, r0	; 63
     8ac:	0f 90       	pop	r0
     8ae:	08 95       	ret
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	08 95       	ret

000008b4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     8b4:	0f 92       	push	r0
     8b6:	0f b6       	in	r0, 0x3f	; 63
     8b8:	f8 94       	cli
     8ba:	0f 92       	push	r0
     8bc:	0b b6       	in	r0, 0x3b	; 59
     8be:	0f 92       	push	r0
     8c0:	0c b6       	in	r0, 0x3c	; 60
     8c2:	0f 92       	push	r0
     8c4:	1f 92       	push	r1
     8c6:	11 24       	eor	r1, r1
     8c8:	2f 92       	push	r2
     8ca:	3f 92       	push	r3
     8cc:	4f 92       	push	r4
     8ce:	5f 92       	push	r5
     8d0:	6f 92       	push	r6
     8d2:	7f 92       	push	r7
     8d4:	8f 92       	push	r8
     8d6:	9f 92       	push	r9
     8d8:	af 92       	push	r10
     8da:	bf 92       	push	r11
     8dc:	cf 92       	push	r12
     8de:	df 92       	push	r13
     8e0:	ef 92       	push	r14
     8e2:	ff 92       	push	r15
     8e4:	0f 93       	push	r16
     8e6:	1f 93       	push	r17
     8e8:	2f 93       	push	r18
     8ea:	3f 93       	push	r19
     8ec:	4f 93       	push	r20
     8ee:	5f 93       	push	r21
     8f0:	6f 93       	push	r22
     8f2:	7f 93       	push	r23
     8f4:	8f 93       	push	r24
     8f6:	9f 93       	push	r25
     8f8:	af 93       	push	r26
     8fa:	bf 93       	push	r27
     8fc:	cf 93       	push	r28
     8fe:	df 93       	push	r29
     900:	ef 93       	push	r30
     902:	ff 93       	push	r31
     904:	a0 91 95 16 	lds	r26, 0x1695	; 0x801695 <pxCurrentTCB>
     908:	b0 91 96 16 	lds	r27, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
     90c:	0d b6       	in	r0, 0x3d	; 61
     90e:	0d 92       	st	X+, r0
     910:	0e b6       	in	r0, 0x3e	; 62
     912:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     914:	eb d6       	rcall	.+3542   	; 0x16ec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     916:	a0 91 95 16 	lds	r26, 0x1695	; 0x801695 <pxCurrentTCB>
     91a:	b0 91 96 16 	lds	r27, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
     91e:	cd 91       	ld	r28, X+
     920:	cd bf       	out	0x3d, r28	; 61
     922:	dd 91       	ld	r29, X+
     924:	de bf       	out	0x3e, r29	; 62
     926:	ff 91       	pop	r31
     928:	ef 91       	pop	r30
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	bf 91       	pop	r27
     930:	af 91       	pop	r26
     932:	9f 91       	pop	r25
     934:	8f 91       	pop	r24
     936:	7f 91       	pop	r23
     938:	6f 91       	pop	r22
     93a:	5f 91       	pop	r21
     93c:	4f 91       	pop	r20
     93e:	3f 91       	pop	r19
     940:	2f 91       	pop	r18
     942:	1f 91       	pop	r17
     944:	0f 91       	pop	r16
     946:	ff 90       	pop	r15
     948:	ef 90       	pop	r14
     94a:	df 90       	pop	r13
     94c:	cf 90       	pop	r12
     94e:	bf 90       	pop	r11
     950:	af 90       	pop	r10
     952:	9f 90       	pop	r9
     954:	8f 90       	pop	r8
     956:	7f 90       	pop	r7
     958:	6f 90       	pop	r6
     95a:	5f 90       	pop	r5
     95c:	4f 90       	pop	r4
     95e:	3f 90       	pop	r3
     960:	2f 90       	pop	r2
     962:	1f 90       	pop	r1
     964:	0f 90       	pop	r0
     966:	0c be       	out	0x3c, r0	; 60
     968:	0f 90       	pop	r0
     96a:	0b be       	out	0x3b, r0	; 59
     96c:	0f 90       	pop	r0
     96e:	0f be       	out	0x3f, r0	; 63
     970:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     972:	08 95       	ret

00000974 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     974:	0f 92       	push	r0
     976:	0f b6       	in	r0, 0x3f	; 63
     978:	f8 94       	cli
     97a:	0f 92       	push	r0
     97c:	0b b6       	in	r0, 0x3b	; 59
     97e:	0f 92       	push	r0
     980:	0c b6       	in	r0, 0x3c	; 60
     982:	0f 92       	push	r0
     984:	1f 92       	push	r1
     986:	11 24       	eor	r1, r1
     988:	2f 92       	push	r2
     98a:	3f 92       	push	r3
     98c:	4f 92       	push	r4
     98e:	5f 92       	push	r5
     990:	6f 92       	push	r6
     992:	7f 92       	push	r7
     994:	8f 92       	push	r8
     996:	9f 92       	push	r9
     998:	af 92       	push	r10
     99a:	bf 92       	push	r11
     99c:	cf 92       	push	r12
     99e:	df 92       	push	r13
     9a0:	ef 92       	push	r14
     9a2:	ff 92       	push	r15
     9a4:	0f 93       	push	r16
     9a6:	1f 93       	push	r17
     9a8:	2f 93       	push	r18
     9aa:	3f 93       	push	r19
     9ac:	4f 93       	push	r20
     9ae:	5f 93       	push	r21
     9b0:	6f 93       	push	r22
     9b2:	7f 93       	push	r23
     9b4:	8f 93       	push	r24
     9b6:	9f 93       	push	r25
     9b8:	af 93       	push	r26
     9ba:	bf 93       	push	r27
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	ef 93       	push	r30
     9c2:	ff 93       	push	r31
     9c4:	a0 91 95 16 	lds	r26, 0x1695	; 0x801695 <pxCurrentTCB>
     9c8:	b0 91 96 16 	lds	r27, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
     9cc:	0d b6       	in	r0, 0x3d	; 61
     9ce:	0d 92       	st	X+, r0
     9d0:	0e b6       	in	r0, 0x3e	; 62
     9d2:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
     9d4:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
     9d6:	80 91 b7 16 	lds	r24, 0x16B7	; 0x8016b7 <ticksRemainingInSec>
     9da:	90 91 b8 16 	lds	r25, 0x16B8	; 0x8016b8 <ticksRemainingInSec+0x1>
     9de:	01 97       	sbiw	r24, 0x01	; 1
     9e0:	90 93 b8 16 	sts	0x16B8, r25	; 0x8016b8 <ticksRemainingInSec+0x1>
     9e4:	80 93 b7 16 	sts	0x16B7, r24	; 0x8016b7 <ticksRemainingInSec>
     9e8:	89 2b       	or	r24, r25
     9ea:	49 f4       	brne	.+18     	; 0x9fe <vPortYieldFromTick+0x8a>
	{
		system_tick();
     9ec:	db db       	rcall	.-2122   	; 0x1a4 <system_tick>
		ticksRemainingInSec = portTickRateHz;
     9ee:	80 91 b5 16 	lds	r24, 0x16B5	; 0x8016b5 <portTickRateHz>
     9f2:	90 91 b6 16 	lds	r25, 0x16B6	; 0x8016b6 <portTickRateHz+0x1>
     9f6:	90 93 b8 16 	sts	0x16B8, r25	; 0x8016b8 <ticksRemainingInSec+0x1>
     9fa:	80 93 b7 16 	sts	0x16B7, r24	; 0x8016b7 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
     9fe:	0c d5       	rcall	.+2584   	; 0x1418 <xTaskIncrementTick>
	{
		vTaskSwitchContext();
     a00:	81 11       	cpse	r24, r1
     a02:	74 d6       	rcall	.+3304   	; 0x16ec <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
     a04:	a0 91 95 16 	lds	r26, 0x1695	; 0x801695 <pxCurrentTCB>
     a08:	b0 91 96 16 	lds	r27, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
     a0c:	cd 91       	ld	r28, X+
     a0e:	cd bf       	out	0x3d, r28	; 61
     a10:	dd 91       	ld	r29, X+
     a12:	de bf       	out	0x3e, r29	; 62
     a14:	ff 91       	pop	r31
     a16:	ef 91       	pop	r30
     a18:	df 91       	pop	r29
     a1a:	cf 91       	pop	r28
     a1c:	bf 91       	pop	r27
     a1e:	af 91       	pop	r26
     a20:	9f 91       	pop	r25
     a22:	8f 91       	pop	r24
     a24:	7f 91       	pop	r23
     a26:	6f 91       	pop	r22
     a28:	5f 91       	pop	r21
     a2a:	4f 91       	pop	r20
     a2c:	3f 91       	pop	r19
     a2e:	2f 91       	pop	r18
     a30:	1f 91       	pop	r17
     a32:	0f 91       	pop	r16
     a34:	ff 90       	pop	r15
     a36:	ef 90       	pop	r14
     a38:	df 90       	pop	r13
     a3a:	cf 90       	pop	r12
     a3c:	bf 90       	pop	r11
     a3e:	af 90       	pop	r10
     a40:	9f 90       	pop	r9
     a42:	8f 90       	pop	r8
     a44:	7f 90       	pop	r7
     a46:	6f 90       	pop	r6
     a48:	5f 90       	pop	r5
     a4a:	4f 90       	pop	r4
     a4c:	3f 90       	pop	r3
     a4e:	2f 90       	pop	r2
     a50:	1f 90       	pop	r1
     a52:	0f 90       	pop	r0
     a54:	0c be       	out	0x3c, r0	; 60
     a56:	0f 90       	pop	r0
     a58:	0b be       	out	0x3b, r0	; 59
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     a60:	08 95       	ret

00000a62 <__vector_32>:
	 * count is incremented after the context is saved.
	 */
	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
     a62:	88 df       	rcall	.-240    	; 0x974 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
     a64:	18 95       	reti

00000a66 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     a66:	0f b6       	in	r0, 0x3f	; 63
     a68:	f8 94       	cli
     a6a:	0f 92       	push	r0
     a6c:	fc 01       	movw	r30, r24
     a6e:	92 8d       	ldd	r25, Z+26	; 0x1a
     a70:	0f 90       	pop	r0
     a72:	0f be       	out	0x3f, r0	; 63
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	91 11       	cpse	r25, r1
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	08 95       	ret

00000a7c <prvCopyDataToQueue>:
     a7c:	0f 93       	push	r16
     a7e:	1f 93       	push	r17
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	ec 01       	movw	r28, r24
     a86:	04 2f       	mov	r16, r20
     a88:	1a 8d       	ldd	r17, Y+26	; 0x1a
     a8a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     a8c:	41 11       	cpse	r20, r1
     a8e:	0b c0       	rjmp	.+22     	; 0xaa6 <prvCopyDataToQueue+0x2a>
     a90:	88 81       	ld	r24, Y
     a92:	99 81       	ldd	r25, Y+1	; 0x01
     a94:	89 2b       	or	r24, r25
     a96:	09 f0       	breq	.+2      	; 0xa9a <prvCopyDataToQueue+0x1e>
     a98:	41 c0       	rjmp	.+130    	; 0xb1c <prvCopyDataToQueue+0xa0>
     a9a:	8a 81       	ldd	r24, Y+2	; 0x02
     a9c:	9b 81       	ldd	r25, Y+3	; 0x03
     a9e:	6a d7       	rcall	.+3796   	; 0x1974 <xTaskPriorityDisinherit>
     aa0:	1b 82       	std	Y+3, r1	; 0x03
     aa2:	1a 82       	std	Y+2, r1	; 0x02
     aa4:	42 c0       	rjmp	.+132    	; 0xb2a <prvCopyDataToQueue+0xae>
     aa6:	01 11       	cpse	r16, r1
     aa8:	17 c0       	rjmp	.+46     	; 0xad8 <prvCopyDataToQueue+0x5c>
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	8c 81       	ldd	r24, Y+4	; 0x04
     aae:	9d 81       	ldd	r25, Y+5	; 0x05
     ab0:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <memcpy>
     ab4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ab6:	8c 81       	ldd	r24, Y+4	; 0x04
     ab8:	9d 81       	ldd	r25, Y+5	; 0x05
     aba:	82 0f       	add	r24, r18
     abc:	91 1d       	adc	r25, r1
     abe:	9d 83       	std	Y+5, r25	; 0x05
     ac0:	8c 83       	std	Y+4, r24	; 0x04
     ac2:	2a 81       	ldd	r18, Y+2	; 0x02
     ac4:	3b 81       	ldd	r19, Y+3	; 0x03
     ac6:	82 17       	cp	r24, r18
     ac8:	93 07       	cpc	r25, r19
     aca:	50 f1       	brcs	.+84     	; 0xb20 <prvCopyDataToQueue+0xa4>
     acc:	88 81       	ld	r24, Y
     ace:	99 81       	ldd	r25, Y+1	; 0x01
     ad0:	9d 83       	std	Y+5, r25	; 0x05
     ad2:	8c 83       	std	Y+4, r24	; 0x04
     ad4:	80 e0       	ldi	r24, 0x00	; 0
     ad6:	29 c0       	rjmp	.+82     	; 0xb2a <prvCopyDataToQueue+0xae>
     ad8:	50 e0       	ldi	r21, 0x00	; 0
     ada:	8e 81       	ldd	r24, Y+6	; 0x06
     adc:	9f 81       	ldd	r25, Y+7	; 0x07
     ade:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <memcpy>
     ae2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ae4:	90 e0       	ldi	r25, 0x00	; 0
     ae6:	91 95       	neg	r25
     ae8:	81 95       	neg	r24
     aea:	91 09       	sbc	r25, r1
     aec:	2e 81       	ldd	r18, Y+6	; 0x06
     aee:	3f 81       	ldd	r19, Y+7	; 0x07
     af0:	28 0f       	add	r18, r24
     af2:	39 1f       	adc	r19, r25
     af4:	3f 83       	std	Y+7, r19	; 0x07
     af6:	2e 83       	std	Y+6, r18	; 0x06
     af8:	48 81       	ld	r20, Y
     afa:	59 81       	ldd	r21, Y+1	; 0x01
     afc:	24 17       	cp	r18, r20
     afe:	35 07       	cpc	r19, r21
     b00:	30 f4       	brcc	.+12     	; 0xb0e <prvCopyDataToQueue+0x92>
     b02:	2a 81       	ldd	r18, Y+2	; 0x02
     b04:	3b 81       	ldd	r19, Y+3	; 0x03
     b06:	82 0f       	add	r24, r18
     b08:	93 1f       	adc	r25, r19
     b0a:	9f 83       	std	Y+7, r25	; 0x07
     b0c:	8e 83       	std	Y+6, r24	; 0x06
     b0e:	02 30       	cpi	r16, 0x02	; 2
     b10:	49 f4       	brne	.+18     	; 0xb24 <prvCopyDataToQueue+0xa8>
     b12:	11 23       	and	r17, r17
     b14:	49 f0       	breq	.+18     	; 0xb28 <prvCopyDataToQueue+0xac>
     b16:	11 50       	subi	r17, 0x01	; 1
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	07 c0       	rjmp	.+14     	; 0xb2a <prvCopyDataToQueue+0xae>
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	05 c0       	rjmp	.+10     	; 0xb2a <prvCopyDataToQueue+0xae>
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	03 c0       	rjmp	.+6      	; 0xb2a <prvCopyDataToQueue+0xae>
     b24:	80 e0       	ldi	r24, 0x00	; 0
     b26:	01 c0       	rjmp	.+2      	; 0xb2a <prvCopyDataToQueue+0xae>
     b28:	80 e0       	ldi	r24, 0x00	; 0
     b2a:	1f 5f       	subi	r17, 0xFF	; 255
     b2c:	1a 8f       	std	Y+26, r17	; 0x1a
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	1f 91       	pop	r17
     b34:	0f 91       	pop	r16
     b36:	08 95       	ret

00000b38 <prvCopyDataFromQueue>:
     b38:	fc 01       	movw	r30, r24
     b3a:	44 8d       	ldd	r20, Z+28	; 0x1c
     b3c:	44 23       	and	r20, r20
     b3e:	a9 f0       	breq	.+42     	; 0xb6a <prvCopyDataFromQueue+0x32>
     b40:	50 e0       	ldi	r21, 0x00	; 0
     b42:	26 81       	ldd	r18, Z+6	; 0x06
     b44:	37 81       	ldd	r19, Z+7	; 0x07
     b46:	24 0f       	add	r18, r20
     b48:	35 1f       	adc	r19, r21
     b4a:	37 83       	std	Z+7, r19	; 0x07
     b4c:	26 83       	std	Z+6, r18	; 0x06
     b4e:	82 81       	ldd	r24, Z+2	; 0x02
     b50:	93 81       	ldd	r25, Z+3	; 0x03
     b52:	28 17       	cp	r18, r24
     b54:	39 07       	cpc	r19, r25
     b56:	20 f0       	brcs	.+8      	; 0xb60 <prvCopyDataFromQueue+0x28>
     b58:	80 81       	ld	r24, Z
     b5a:	91 81       	ldd	r25, Z+1	; 0x01
     b5c:	97 83       	std	Z+7, r25	; 0x07
     b5e:	86 83       	std	Z+6, r24	; 0x06
     b60:	cb 01       	movw	r24, r22
     b62:	66 81       	ldd	r22, Z+6	; 0x06
     b64:	77 81       	ldd	r23, Z+7	; 0x07
     b66:	0c 94 0a 0f 	jmp	0x1e14	; 0x1e14 <memcpy>
     b6a:	08 95       	ret

00000b6c <prvUnlockQueue>:
     b6c:	ef 92       	push	r14
     b6e:	ff 92       	push	r15
     b70:	0f 93       	push	r16
     b72:	1f 93       	push	r17
     b74:	cf 93       	push	r28
     b76:	8c 01       	movw	r16, r24
     b78:	0f b6       	in	r0, 0x3f	; 63
     b7a:	f8 94       	cli
     b7c:	0f 92       	push	r0
     b7e:	fc 01       	movw	r30, r24
     b80:	c6 8d       	ldd	r28, Z+30	; 0x1e
     b82:	1c 16       	cp	r1, r28
     b84:	9c f4       	brge	.+38     	; 0xbac <prvUnlockQueue+0x40>
     b86:	81 89       	ldd	r24, Z+17	; 0x11
     b88:	81 11       	cpse	r24, r1
     b8a:	06 c0       	rjmp	.+12     	; 0xb98 <prvUnlockQueue+0x2c>
     b8c:	0f c0       	rjmp	.+30     	; 0xbac <prvUnlockQueue+0x40>
     b8e:	f8 01       	movw	r30, r16
     b90:	81 89       	ldd	r24, Z+17	; 0x11
     b92:	81 11       	cpse	r24, r1
     b94:	05 c0       	rjmp	.+10     	; 0xba0 <prvUnlockQueue+0x34>
     b96:	0a c0       	rjmp	.+20     	; 0xbac <prvUnlockQueue+0x40>
     b98:	78 01       	movw	r14, r16
     b9a:	f1 e1       	ldi	r31, 0x11	; 17
     b9c:	ef 0e       	add	r14, r31
     b9e:	f1 1c       	adc	r15, r1
     ba0:	c7 01       	movw	r24, r14
     ba2:	4e d6       	rcall	.+3228   	; 0x1840 <xTaskRemoveFromEventList>
     ba4:	81 11       	cpse	r24, r1
     ba6:	d4 d6       	rcall	.+3496   	; 0x1950 <vTaskMissedYield>
     ba8:	c1 50       	subi	r28, 0x01	; 1
     baa:	89 f7       	brne	.-30     	; 0xb8e <prvUnlockQueue+0x22>
     bac:	8f ef       	ldi	r24, 0xFF	; 255
     bae:	f8 01       	movw	r30, r16
     bb0:	86 8f       	std	Z+30, r24	; 0x1e
     bb2:	0f 90       	pop	r0
     bb4:	0f be       	out	0x3f, r0	; 63
     bb6:	0f b6       	in	r0, 0x3f	; 63
     bb8:	f8 94       	cli
     bba:	0f 92       	push	r0
     bbc:	c5 8d       	ldd	r28, Z+29	; 0x1d
     bbe:	1c 16       	cp	r1, r28
     bc0:	9c f4       	brge	.+38     	; 0xbe8 <prvUnlockQueue+0x7c>
     bc2:	80 85       	ldd	r24, Z+8	; 0x08
     bc4:	81 11       	cpse	r24, r1
     bc6:	06 c0       	rjmp	.+12     	; 0xbd4 <prvUnlockQueue+0x68>
     bc8:	0f c0       	rjmp	.+30     	; 0xbe8 <prvUnlockQueue+0x7c>
     bca:	f8 01       	movw	r30, r16
     bcc:	80 85       	ldd	r24, Z+8	; 0x08
     bce:	81 11       	cpse	r24, r1
     bd0:	05 c0       	rjmp	.+10     	; 0xbdc <prvUnlockQueue+0x70>
     bd2:	0a c0       	rjmp	.+20     	; 0xbe8 <prvUnlockQueue+0x7c>
     bd4:	78 01       	movw	r14, r16
     bd6:	f8 e0       	ldi	r31, 0x08	; 8
     bd8:	ef 0e       	add	r14, r31
     bda:	f1 1c       	adc	r15, r1
     bdc:	c7 01       	movw	r24, r14
     bde:	30 d6       	rcall	.+3168   	; 0x1840 <xTaskRemoveFromEventList>
     be0:	81 11       	cpse	r24, r1
     be2:	b6 d6       	rcall	.+3436   	; 0x1950 <vTaskMissedYield>
     be4:	c1 50       	subi	r28, 0x01	; 1
     be6:	89 f7       	brne	.-30     	; 0xbca <prvUnlockQueue+0x5e>
     be8:	8f ef       	ldi	r24, 0xFF	; 255
     bea:	f8 01       	movw	r30, r16
     bec:	85 8f       	std	Z+29, r24	; 0x1d
     bee:	0f 90       	pop	r0
     bf0:	0f be       	out	0x3f, r0	; 63
     bf2:	cf 91       	pop	r28
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	ff 90       	pop	r15
     bfa:	ef 90       	pop	r14
     bfc:	08 95       	ret

00000bfe <xQueueGenericReset>:
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	ec 01       	movw	r28, r24
     c04:	0f b6       	in	r0, 0x3f	; 63
     c06:	f8 94       	cli
     c08:	0f 92       	push	r0
     c0a:	48 81       	ld	r20, Y
     c0c:	59 81       	ldd	r21, Y+1	; 0x01
     c0e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	7b 8d       	ldd	r23, Y+27	; 0x1b
     c14:	72 9f       	mul	r23, r18
     c16:	c0 01       	movw	r24, r0
     c18:	73 9f       	mul	r23, r19
     c1a:	90 0d       	add	r25, r0
     c1c:	11 24       	eor	r1, r1
     c1e:	fa 01       	movw	r30, r20
     c20:	e8 0f       	add	r30, r24
     c22:	f9 1f       	adc	r31, r25
     c24:	fb 83       	std	Y+3, r31	; 0x03
     c26:	ea 83       	std	Y+2, r30	; 0x02
     c28:	1a 8e       	std	Y+26, r1	; 0x1a
     c2a:	5d 83       	std	Y+5, r21	; 0x05
     c2c:	4c 83       	std	Y+4, r20	; 0x04
     c2e:	82 1b       	sub	r24, r18
     c30:	93 0b       	sbc	r25, r19
     c32:	84 0f       	add	r24, r20
     c34:	95 1f       	adc	r25, r21
     c36:	9f 83       	std	Y+7, r25	; 0x07
     c38:	8e 83       	std	Y+6, r24	; 0x06
     c3a:	8f ef       	ldi	r24, 0xFF	; 255
     c3c:	8d 8f       	std	Y+29, r24	; 0x1d
     c3e:	8e 8f       	std	Y+30, r24	; 0x1e
     c40:	61 11       	cpse	r22, r1
     c42:	0a c0       	rjmp	.+20     	; 0xc58 <xQueueGenericReset+0x5a>
     c44:	88 85       	ldd	r24, Y+8	; 0x08
     c46:	88 23       	and	r24, r24
     c48:	69 f0       	breq	.+26     	; 0xc64 <xQueueGenericReset+0x66>
     c4a:	ce 01       	movw	r24, r28
     c4c:	08 96       	adiw	r24, 0x08	; 8
     c4e:	f8 d5       	rcall	.+3056   	; 0x1840 <xTaskRemoveFromEventList>
     c50:	88 23       	and	r24, r24
     c52:	41 f0       	breq	.+16     	; 0xc64 <xQueueGenericReset+0x66>
     c54:	2f de       	rcall	.-930    	; 0x8b4 <vPortYield>
     c56:	06 c0       	rjmp	.+12     	; 0xc64 <xQueueGenericReset+0x66>
     c58:	ce 01       	movw	r24, r28
     c5a:	08 96       	adiw	r24, 0x08	; 8
     c5c:	e5 dc       	rcall	.-1590   	; 0x628 <vListInitialise>
     c5e:	ce 01       	movw	r24, r28
     c60:	41 96       	adiw	r24, 0x11	; 17
     c62:	e2 dc       	rcall	.-1596   	; 0x628 <vListInitialise>
     c64:	0f 90       	pop	r0
     c66:	0f be       	out	0x3f, r0	; 63
     c68:	81 e0       	ldi	r24, 0x01	; 1
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	08 95       	ret

00000c70 <xQueueGenericCreate>:
     c70:	0f 93       	push	r16
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
     c78:	08 2f       	mov	r16, r24
     c7a:	16 2f       	mov	r17, r22
     c7c:	66 23       	and	r22, r22
     c7e:	b1 f0       	breq	.+44     	; 0xcac <xQueueGenericCreate+0x3c>
     c80:	86 9f       	mul	r24, r22
     c82:	c0 01       	movw	r24, r0
     c84:	11 24       	eor	r1, r1
     c86:	4f 96       	adiw	r24, 0x1f	; 31
     c88:	ce db       	rcall	.-2148   	; 0x426 <pvPortMalloc>
     c8a:	ec 01       	movw	r28, r24
     c8c:	00 97       	sbiw	r24, 0x00	; 0
     c8e:	39 f4       	brne	.+14     	; 0xc9e <xQueueGenericCreate+0x2e>
     c90:	13 c0       	rjmp	.+38     	; 0xcb8 <xQueueGenericCreate+0x48>
     c92:	0b 8f       	std	Y+27, r16	; 0x1b
     c94:	1c 8f       	std	Y+28, r17	; 0x1c
     c96:	61 e0       	ldi	r22, 0x01	; 1
     c98:	ce 01       	movw	r24, r28
     c9a:	b1 df       	rcall	.-158    	; 0xbfe <xQueueGenericReset>
     c9c:	0d c0       	rjmp	.+26     	; 0xcb8 <xQueueGenericCreate+0x48>
     c9e:	4f 96       	adiw	r24, 0x1f	; 31
     ca0:	99 83       	std	Y+1, r25	; 0x01
     ca2:	88 83       	st	Y, r24
     ca4:	f6 cf       	rjmp	.-20     	; 0xc92 <xQueueGenericCreate+0x22>
     ca6:	d9 83       	std	Y+1, r29	; 0x01
     ca8:	c8 83       	st	Y, r28
     caa:	f3 cf       	rjmp	.-26     	; 0xc92 <xQueueGenericCreate+0x22>
     cac:	8f e1       	ldi	r24, 0x1F	; 31
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	ba db       	rcall	.-2188   	; 0x426 <pvPortMalloc>
     cb2:	ec 01       	movw	r28, r24
     cb4:	89 2b       	or	r24, r25
     cb6:	b9 f7       	brne	.-18     	; 0xca6 <xQueueGenericCreate+0x36>
     cb8:	ce 01       	movw	r24, r28
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	1f 91       	pop	r17
     cc0:	0f 91       	pop	r16
     cc2:	08 95       	ret

00000cc4 <xQueueGenericSend>:
     cc4:	9f 92       	push	r9
     cc6:	af 92       	push	r10
     cc8:	bf 92       	push	r11
     cca:	cf 92       	push	r12
     ccc:	df 92       	push	r13
     cce:	ef 92       	push	r14
     cd0:	ff 92       	push	r15
     cd2:	0f 93       	push	r16
     cd4:	1f 93       	push	r17
     cd6:	cf 93       	push	r28
     cd8:	df 93       	push	r29
     cda:	00 d0       	rcall	.+0      	; 0xcdc <xQueueGenericSend+0x18>
     cdc:	1f 92       	push	r1
     cde:	1f 92       	push	r1
     ce0:	cd b7       	in	r28, 0x3d	; 61
     ce2:	de b7       	in	r29, 0x3e	; 62
     ce4:	8c 01       	movw	r16, r24
     ce6:	6b 01       	movw	r12, r22
     ce8:	5d 83       	std	Y+5, r21	; 0x05
     cea:	4c 83       	std	Y+4, r20	; 0x04
     cec:	a2 2e       	mov	r10, r18
     cee:	b1 2c       	mov	r11, r1
     cf0:	99 24       	eor	r9, r9
     cf2:	93 94       	inc	r9
     cf4:	7c 01       	movw	r14, r24
     cf6:	88 e0       	ldi	r24, 0x08	; 8
     cf8:	e8 0e       	add	r14, r24
     cfa:	f1 1c       	adc	r15, r1
     cfc:	0f b6       	in	r0, 0x3f	; 63
     cfe:	f8 94       	cli
     d00:	0f 92       	push	r0
     d02:	f8 01       	movw	r30, r16
     d04:	92 8d       	ldd	r25, Z+26	; 0x1a
     d06:	83 8d       	ldd	r24, Z+27	; 0x1b
     d08:	98 17       	cp	r25, r24
     d0a:	18 f0       	brcs	.+6      	; 0xd12 <xQueueGenericSend+0x4e>
     d0c:	f2 e0       	ldi	r31, 0x02	; 2
     d0e:	af 12       	cpse	r10, r31
     d10:	15 c0       	rjmp	.+42     	; 0xd3c <xQueueGenericSend+0x78>
     d12:	4a 2d       	mov	r20, r10
     d14:	b6 01       	movw	r22, r12
     d16:	c8 01       	movw	r24, r16
     d18:	b1 de       	rcall	.-670    	; 0xa7c <prvCopyDataToQueue>
     d1a:	f8 01       	movw	r30, r16
     d1c:	91 89       	ldd	r25, Z+17	; 0x11
     d1e:	99 23       	and	r25, r25
     d20:	39 f0       	breq	.+14     	; 0xd30 <xQueueGenericSend+0x6c>
     d22:	c8 01       	movw	r24, r16
     d24:	41 96       	adiw	r24, 0x11	; 17
     d26:	8c d5       	rcall	.+2840   	; 0x1840 <xTaskRemoveFromEventList>
     d28:	88 23       	and	r24, r24
     d2a:	21 f0       	breq	.+8      	; 0xd34 <xQueueGenericSend+0x70>
     d2c:	c3 dd       	rcall	.-1146   	; 0x8b4 <vPortYield>
     d2e:	02 c0       	rjmp	.+4      	; 0xd34 <xQueueGenericSend+0x70>
     d30:	81 11       	cpse	r24, r1
     d32:	c0 dd       	rcall	.-1152   	; 0x8b4 <vPortYield>
     d34:	0f 90       	pop	r0
     d36:	0f be       	out	0x3f, r0	; 63
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	45 c0       	rjmp	.+138    	; 0xdc6 <xQueueGenericSend+0x102>
     d3c:	8c 81       	ldd	r24, Y+4	; 0x04
     d3e:	9d 81       	ldd	r25, Y+5	; 0x05
     d40:	89 2b       	or	r24, r25
     d42:	21 f4       	brne	.+8      	; 0xd4c <xQueueGenericSend+0x88>
     d44:	0f 90       	pop	r0
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	80 e0       	ldi	r24, 0x00	; 0
     d4a:	3d c0       	rjmp	.+122    	; 0xdc6 <xQueueGenericSend+0x102>
     d4c:	b1 10       	cpse	r11, r1
     d4e:	04 c0       	rjmp	.+8      	; 0xd58 <xQueueGenericSend+0x94>
     d50:	ce 01       	movw	r24, r28
     d52:	01 96       	adiw	r24, 0x01	; 1
     d54:	bd d5       	rcall	.+2938   	; 0x18d0 <vTaskInternalSetTimeOutState>
     d56:	b9 2c       	mov	r11, r9
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63
     d5c:	4d d3       	rcall	.+1690   	; 0x13f8 <vTaskSuspendAll>
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	0f 92       	push	r0
     d64:	f8 01       	movw	r30, r16
     d66:	85 8d       	ldd	r24, Z+29	; 0x1d
     d68:	8f 3f       	cpi	r24, 0xFF	; 255
     d6a:	09 f4       	brne	.+2      	; 0xd6e <xQueueGenericSend+0xaa>
     d6c:	15 8e       	std	Z+29, r1	; 0x1d
     d6e:	f8 01       	movw	r30, r16
     d70:	86 8d       	ldd	r24, Z+30	; 0x1e
     d72:	8f 3f       	cpi	r24, 0xFF	; 255
     d74:	09 f4       	brne	.+2      	; 0xd78 <xQueueGenericSend+0xb4>
     d76:	16 8e       	std	Z+30, r1	; 0x1e
     d78:	0f 90       	pop	r0
     d7a:	0f be       	out	0x3f, r0	; 63
     d7c:	be 01       	movw	r22, r28
     d7e:	6c 5f       	subi	r22, 0xFC	; 252
     d80:	7f 4f       	sbci	r23, 0xFF	; 255
     d82:	ce 01       	movw	r24, r28
     d84:	01 96       	adiw	r24, 0x01	; 1
     d86:	af d5       	rcall	.+2910   	; 0x18e6 <xTaskCheckForTimeOut>
     d88:	81 11       	cpse	r24, r1
     d8a:	19 c0       	rjmp	.+50     	; 0xdbe <xQueueGenericSend+0xfa>
     d8c:	0f b6       	in	r0, 0x3f	; 63
     d8e:	f8 94       	cli
     d90:	0f 92       	push	r0
     d92:	f8 01       	movw	r30, r16
     d94:	92 8d       	ldd	r25, Z+26	; 0x1a
     d96:	83 8d       	ldd	r24, Z+27	; 0x1b
     d98:	0f 90       	pop	r0
     d9a:	0f be       	out	0x3f, r0	; 63
     d9c:	98 13       	cpse	r25, r24
     d9e:	0b c0       	rjmp	.+22     	; 0xdb6 <xQueueGenericSend+0xf2>
     da0:	6c 81       	ldd	r22, Y+4	; 0x04
     da2:	7d 81       	ldd	r23, Y+5	; 0x05
     da4:	c7 01       	movw	r24, r14
     da6:	23 d5       	rcall	.+2630   	; 0x17ee <vTaskPlaceOnEventList>
     da8:	c8 01       	movw	r24, r16
     daa:	e0 de       	rcall	.-576    	; 0xb6c <prvUnlockQueue>
     dac:	ec d3       	rcall	.+2008   	; 0x1586 <xTaskResumeAll>
     dae:	81 11       	cpse	r24, r1
     db0:	a5 cf       	rjmp	.-182    	; 0xcfc <xQueueGenericSend+0x38>
     db2:	80 dd       	rcall	.-1280   	; 0x8b4 <vPortYield>
     db4:	a3 cf       	rjmp	.-186    	; 0xcfc <xQueueGenericSend+0x38>
     db6:	c8 01       	movw	r24, r16
     db8:	d9 de       	rcall	.-590    	; 0xb6c <prvUnlockQueue>
     dba:	e5 d3       	rcall	.+1994   	; 0x1586 <xTaskResumeAll>
     dbc:	9f cf       	rjmp	.-194    	; 0xcfc <xQueueGenericSend+0x38>
     dbe:	c8 01       	movw	r24, r16
     dc0:	d5 de       	rcall	.-598    	; 0xb6c <prvUnlockQueue>
     dc2:	e1 d3       	rcall	.+1986   	; 0x1586 <xTaskResumeAll>
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	0f 90       	pop	r0
     dc8:	0f 90       	pop	r0
     dca:	0f 90       	pop	r0
     dcc:	0f 90       	pop	r0
     dce:	0f 90       	pop	r0
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	ff 90       	pop	r15
     dda:	ef 90       	pop	r14
     ddc:	df 90       	pop	r13
     dde:	cf 90       	pop	r12
     de0:	bf 90       	pop	r11
     de2:	af 90       	pop	r10
     de4:	9f 90       	pop	r9
     de6:	08 95       	ret

00000de8 <xQueueGenericSendFromISR>:
     de8:	ef 92       	push	r14
     dea:	ff 92       	push	r15
     dec:	0f 93       	push	r16
     dee:	1f 93       	push	r17
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
     df4:	8a 01       	movw	r16, r20
     df6:	fc 01       	movw	r30, r24
     df8:	52 8d       	ldd	r21, Z+26	; 0x1a
     dfa:	33 8d       	ldd	r19, Z+27	; 0x1b
     dfc:	53 17       	cp	r21, r19
     dfe:	10 f0       	brcs	.+4      	; 0xe04 <xQueueGenericSendFromISR+0x1c>
     e00:	22 30       	cpi	r18, 0x02	; 2
     e02:	e1 f4       	brne	.+56     	; 0xe3c <xQueueGenericSendFromISR+0x54>
     e04:	42 2f       	mov	r20, r18
     e06:	78 01       	movw	r14, r16
     e08:	ec 01       	movw	r28, r24
     e0a:	1e 8d       	ldd	r17, Y+30	; 0x1e
     e0c:	37 de       	rcall	.-914    	; 0xa7c <prvCopyDataToQueue>
     e0e:	1f 3f       	cpi	r17, 0xFF	; 255
     e10:	79 f4       	brne	.+30     	; 0xe30 <xQueueGenericSendFromISR+0x48>
     e12:	89 89       	ldd	r24, Y+17	; 0x11
     e14:	88 23       	and	r24, r24
     e16:	a1 f0       	breq	.+40     	; 0xe40 <xQueueGenericSendFromISR+0x58>
     e18:	ce 01       	movw	r24, r28
     e1a:	41 96       	adiw	r24, 0x11	; 17
     e1c:	11 d5       	rcall	.+2594   	; 0x1840 <xTaskRemoveFromEventList>
     e1e:	88 23       	and	r24, r24
     e20:	89 f0       	breq	.+34     	; 0xe44 <xQueueGenericSendFromISR+0x5c>
     e22:	e1 14       	cp	r14, r1
     e24:	f1 04       	cpc	r15, r1
     e26:	81 f0       	breq	.+32     	; 0xe48 <xQueueGenericSendFromISR+0x60>
     e28:	81 e0       	ldi	r24, 0x01	; 1
     e2a:	f7 01       	movw	r30, r14
     e2c:	80 83       	st	Z, r24
     e2e:	0d c0       	rjmp	.+26     	; 0xe4a <xQueueGenericSendFromISR+0x62>
     e30:	ff 24       	eor	r15, r15
     e32:	f3 94       	inc	r15
     e34:	f1 0e       	add	r15, r17
     e36:	fe 8e       	std	Y+30, r15	; 0x1e
     e38:	81 e0       	ldi	r24, 0x01	; 1
     e3a:	07 c0       	rjmp	.+14     	; 0xe4a <xQueueGenericSendFromISR+0x62>
     e3c:	80 e0       	ldi	r24, 0x00	; 0
     e3e:	05 c0       	rjmp	.+10     	; 0xe4a <xQueueGenericSendFromISR+0x62>
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	03 c0       	rjmp	.+6      	; 0xe4a <xQueueGenericSendFromISR+0x62>
     e44:	81 e0       	ldi	r24, 0x01	; 1
     e46:	01 c0       	rjmp	.+2      	; 0xe4a <xQueueGenericSendFromISR+0x62>
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	df 91       	pop	r29
     e4c:	cf 91       	pop	r28
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	ff 90       	pop	r15
     e54:	ef 90       	pop	r14
     e56:	08 95       	ret

00000e58 <xQueueReceive>:
     e58:	9f 92       	push	r9
     e5a:	af 92       	push	r10
     e5c:	bf 92       	push	r11
     e5e:	cf 92       	push	r12
     e60:	df 92       	push	r13
     e62:	ef 92       	push	r14
     e64:	ff 92       	push	r15
     e66:	0f 93       	push	r16
     e68:	1f 93       	push	r17
     e6a:	cf 93       	push	r28
     e6c:	df 93       	push	r29
     e6e:	00 d0       	rcall	.+0      	; 0xe70 <xQueueReceive+0x18>
     e70:	1f 92       	push	r1
     e72:	1f 92       	push	r1
     e74:	cd b7       	in	r28, 0x3d	; 61
     e76:	de b7       	in	r29, 0x3e	; 62
     e78:	8c 01       	movw	r16, r24
     e7a:	5b 01       	movw	r10, r22
     e7c:	5d 83       	std	Y+5, r21	; 0x05
     e7e:	4c 83       	std	Y+4, r20	; 0x04
     e80:	e1 2c       	mov	r14, r1
     e82:	99 24       	eor	r9, r9
     e84:	93 94       	inc	r9
     e86:	6c 01       	movw	r12, r24
     e88:	81 e1       	ldi	r24, 0x11	; 17
     e8a:	c8 0e       	add	r12, r24
     e8c:	d1 1c       	adc	r13, r1
     e8e:	0f b6       	in	r0, 0x3f	; 63
     e90:	f8 94       	cli
     e92:	0f 92       	push	r0
     e94:	f8 01       	movw	r30, r16
     e96:	f2 8c       	ldd	r15, Z+26	; 0x1a
     e98:	ff 20       	and	r15, r15
     e9a:	91 f0       	breq	.+36     	; 0xec0 <xQueueReceive+0x68>
     e9c:	b5 01       	movw	r22, r10
     e9e:	c8 01       	movw	r24, r16
     ea0:	4b de       	rcall	.-874    	; 0xb38 <prvCopyDataFromQueue>
     ea2:	fa 94       	dec	r15
     ea4:	f8 01       	movw	r30, r16
     ea6:	f2 8e       	std	Z+26, r15	; 0x1a
     ea8:	80 85       	ldd	r24, Z+8	; 0x08
     eaa:	88 23       	and	r24, r24
     eac:	29 f0       	breq	.+10     	; 0xeb8 <xQueueReceive+0x60>
     eae:	c8 01       	movw	r24, r16
     eb0:	08 96       	adiw	r24, 0x08	; 8
     eb2:	c6 d4       	rcall	.+2444   	; 0x1840 <xTaskRemoveFromEventList>
     eb4:	81 11       	cpse	r24, r1
     eb6:	fe dc       	rcall	.-1540   	; 0x8b4 <vPortYield>
     eb8:	0f 90       	pop	r0
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	81 e0       	ldi	r24, 0x01	; 1
     ebe:	44 c0       	rjmp	.+136    	; 0xf48 <xQueueReceive+0xf0>
     ec0:	8c 81       	ldd	r24, Y+4	; 0x04
     ec2:	9d 81       	ldd	r25, Y+5	; 0x05
     ec4:	89 2b       	or	r24, r25
     ec6:	21 f4       	brne	.+8      	; 0xed0 <xQueueReceive+0x78>
     ec8:	0f 90       	pop	r0
     eca:	0f be       	out	0x3f, r0	; 63
     ecc:	80 e0       	ldi	r24, 0x00	; 0
     ece:	3c c0       	rjmp	.+120    	; 0xf48 <xQueueReceive+0xf0>
     ed0:	e1 10       	cpse	r14, r1
     ed2:	04 c0       	rjmp	.+8      	; 0xedc <xQueueReceive+0x84>
     ed4:	ce 01       	movw	r24, r28
     ed6:	01 96       	adiw	r24, 0x01	; 1
     ed8:	fb d4       	rcall	.+2550   	; 0x18d0 <vTaskInternalSetTimeOutState>
     eda:	e9 2c       	mov	r14, r9
     edc:	0f 90       	pop	r0
     ede:	0f be       	out	0x3f, r0	; 63
     ee0:	8b d2       	rcall	.+1302   	; 0x13f8 <vTaskSuspendAll>
     ee2:	0f b6       	in	r0, 0x3f	; 63
     ee4:	f8 94       	cli
     ee6:	0f 92       	push	r0
     ee8:	f8 01       	movw	r30, r16
     eea:	85 8d       	ldd	r24, Z+29	; 0x1d
     eec:	8f 3f       	cpi	r24, 0xFF	; 255
     eee:	09 f4       	brne	.+2      	; 0xef2 <xQueueReceive+0x9a>
     ef0:	15 8e       	std	Z+29, r1	; 0x1d
     ef2:	f8 01       	movw	r30, r16
     ef4:	86 8d       	ldd	r24, Z+30	; 0x1e
     ef6:	8f 3f       	cpi	r24, 0xFF	; 255
     ef8:	09 f4       	brne	.+2      	; 0xefc <xQueueReceive+0xa4>
     efa:	16 8e       	std	Z+30, r1	; 0x1e
     efc:	0f 90       	pop	r0
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	be 01       	movw	r22, r28
     f02:	6c 5f       	subi	r22, 0xFC	; 252
     f04:	7f 4f       	sbci	r23, 0xFF	; 255
     f06:	ce 01       	movw	r24, r28
     f08:	01 96       	adiw	r24, 0x01	; 1
     f0a:	ed d4       	rcall	.+2522   	; 0x18e6 <xTaskCheckForTimeOut>
     f0c:	81 11       	cpse	r24, r1
     f0e:	13 c0       	rjmp	.+38     	; 0xf36 <xQueueReceive+0xde>
     f10:	c8 01       	movw	r24, r16
     f12:	a9 dd       	rcall	.-1198   	; 0xa66 <prvIsQueueEmpty>
     f14:	88 23       	and	r24, r24
     f16:	59 f0       	breq	.+22     	; 0xf2e <xQueueReceive+0xd6>
     f18:	6c 81       	ldd	r22, Y+4	; 0x04
     f1a:	7d 81       	ldd	r23, Y+5	; 0x05
     f1c:	c6 01       	movw	r24, r12
     f1e:	67 d4       	rcall	.+2254   	; 0x17ee <vTaskPlaceOnEventList>
     f20:	c8 01       	movw	r24, r16
     f22:	24 de       	rcall	.-952    	; 0xb6c <prvUnlockQueue>
     f24:	30 d3       	rcall	.+1632   	; 0x1586 <xTaskResumeAll>
     f26:	81 11       	cpse	r24, r1
     f28:	b2 cf       	rjmp	.-156    	; 0xe8e <xQueueReceive+0x36>
     f2a:	c4 dc       	rcall	.-1656   	; 0x8b4 <vPortYield>
     f2c:	b0 cf       	rjmp	.-160    	; 0xe8e <xQueueReceive+0x36>
     f2e:	c8 01       	movw	r24, r16
     f30:	1d de       	rcall	.-966    	; 0xb6c <prvUnlockQueue>
     f32:	29 d3       	rcall	.+1618   	; 0x1586 <xTaskResumeAll>
     f34:	ac cf       	rjmp	.-168    	; 0xe8e <xQueueReceive+0x36>
     f36:	c8 01       	movw	r24, r16
     f38:	19 de       	rcall	.-974    	; 0xb6c <prvUnlockQueue>
     f3a:	25 d3       	rcall	.+1610   	; 0x1586 <xTaskResumeAll>
     f3c:	c8 01       	movw	r24, r16
     f3e:	93 dd       	rcall	.-1242   	; 0xa66 <prvIsQueueEmpty>
     f40:	88 23       	and	r24, r24
     f42:	09 f4       	brne	.+2      	; 0xf46 <xQueueReceive+0xee>
     f44:	a4 cf       	rjmp	.-184    	; 0xe8e <xQueueReceive+0x36>
     f46:	80 e0       	ldi	r24, 0x00	; 0
     f48:	0f 90       	pop	r0
     f4a:	0f 90       	pop	r0
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	0f 90       	pop	r0
     f52:	df 91       	pop	r29
     f54:	cf 91       	pop	r28
     f56:	1f 91       	pop	r17
     f58:	0f 91       	pop	r16
     f5a:	ff 90       	pop	r15
     f5c:	ef 90       	pop	r14
     f5e:	df 90       	pop	r13
     f60:	cf 90       	pop	r12
     f62:	bf 90       	pop	r11
     f64:	af 90       	pop	r10
     f66:	9f 90       	pop	r9
     f68:	08 95       	ret

00000f6a <xQueuePeek>:
     f6a:	af 92       	push	r10
     f6c:	bf 92       	push	r11
     f6e:	cf 92       	push	r12
     f70:	df 92       	push	r13
     f72:	ef 92       	push	r14
     f74:	ff 92       	push	r15
     f76:	0f 93       	push	r16
     f78:	1f 93       	push	r17
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	00 d0       	rcall	.+0      	; 0xf80 <xQueuePeek+0x16>
     f80:	1f 92       	push	r1
     f82:	1f 92       	push	r1
     f84:	cd b7       	in	r28, 0x3d	; 61
     f86:	de b7       	in	r29, 0x3e	; 62
     f88:	8c 01       	movw	r16, r24
     f8a:	6b 01       	movw	r12, r22
     f8c:	5d 83       	std	Y+5, r21	; 0x05
     f8e:	4c 83       	std	Y+4, r20	; 0x04
     f90:	b1 2c       	mov	r11, r1
     f92:	aa 24       	eor	r10, r10
     f94:	a3 94       	inc	r10
     f96:	7c 01       	movw	r14, r24
     f98:	81 e1       	ldi	r24, 0x11	; 17
     f9a:	e8 0e       	add	r14, r24
     f9c:	f1 1c       	adc	r15, r1
     f9e:	0f b6       	in	r0, 0x3f	; 63
     fa0:	f8 94       	cli
     fa2:	0f 92       	push	r0
     fa4:	f8 01       	movw	r30, r16
     fa6:	82 8d       	ldd	r24, Z+26	; 0x1a
     fa8:	88 23       	and	r24, r24
     faa:	a1 f0       	breq	.+40     	; 0xfd4 <xQueuePeek+0x6a>
     fac:	e6 80       	ldd	r14, Z+6	; 0x06
     fae:	f7 80       	ldd	r15, Z+7	; 0x07
     fb0:	b6 01       	movw	r22, r12
     fb2:	c8 01       	movw	r24, r16
     fb4:	c1 dd       	rcall	.-1150   	; 0xb38 <prvCopyDataFromQueue>
     fb6:	f8 01       	movw	r30, r16
     fb8:	f7 82       	std	Z+7, r15	; 0x07
     fba:	e6 82       	std	Z+6, r14	; 0x06
     fbc:	81 89       	ldd	r24, Z+17	; 0x11
     fbe:	88 23       	and	r24, r24
     fc0:	29 f0       	breq	.+10     	; 0xfcc <xQueuePeek+0x62>
     fc2:	c8 01       	movw	r24, r16
     fc4:	41 96       	adiw	r24, 0x11	; 17
     fc6:	3c d4       	rcall	.+2168   	; 0x1840 <xTaskRemoveFromEventList>
     fc8:	81 11       	cpse	r24, r1
     fca:	74 dc       	rcall	.-1816   	; 0x8b4 <vPortYield>
     fcc:	0f 90       	pop	r0
     fce:	0f be       	out	0x3f, r0	; 63
     fd0:	81 e0       	ldi	r24, 0x01	; 1
     fd2:	44 c0       	rjmp	.+136    	; 0x105c <xQueuePeek+0xf2>
     fd4:	8c 81       	ldd	r24, Y+4	; 0x04
     fd6:	9d 81       	ldd	r25, Y+5	; 0x05
     fd8:	89 2b       	or	r24, r25
     fda:	21 f4       	brne	.+8      	; 0xfe4 <xQueuePeek+0x7a>
     fdc:	0f 90       	pop	r0
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	3c c0       	rjmp	.+120    	; 0x105c <xQueuePeek+0xf2>
     fe4:	b1 10       	cpse	r11, r1
     fe6:	04 c0       	rjmp	.+8      	; 0xff0 <xQueuePeek+0x86>
     fe8:	ce 01       	movw	r24, r28
     fea:	01 96       	adiw	r24, 0x01	; 1
     fec:	71 d4       	rcall	.+2274   	; 0x18d0 <vTaskInternalSetTimeOutState>
     fee:	ba 2c       	mov	r11, r10
     ff0:	0f 90       	pop	r0
     ff2:	0f be       	out	0x3f, r0	; 63
     ff4:	01 d2       	rcall	.+1026   	; 0x13f8 <vTaskSuspendAll>
     ff6:	0f b6       	in	r0, 0x3f	; 63
     ff8:	f8 94       	cli
     ffa:	0f 92       	push	r0
     ffc:	f8 01       	movw	r30, r16
     ffe:	85 8d       	ldd	r24, Z+29	; 0x1d
    1000:	8f 3f       	cpi	r24, 0xFF	; 255
    1002:	09 f4       	brne	.+2      	; 0x1006 <xQueuePeek+0x9c>
    1004:	15 8e       	std	Z+29, r1	; 0x1d
    1006:	f8 01       	movw	r30, r16
    1008:	86 8d       	ldd	r24, Z+30	; 0x1e
    100a:	8f 3f       	cpi	r24, 0xFF	; 255
    100c:	09 f4       	brne	.+2      	; 0x1010 <xQueuePeek+0xa6>
    100e:	16 8e       	std	Z+30, r1	; 0x1e
    1010:	0f 90       	pop	r0
    1012:	0f be       	out	0x3f, r0	; 63
    1014:	be 01       	movw	r22, r28
    1016:	6c 5f       	subi	r22, 0xFC	; 252
    1018:	7f 4f       	sbci	r23, 0xFF	; 255
    101a:	ce 01       	movw	r24, r28
    101c:	01 96       	adiw	r24, 0x01	; 1
    101e:	63 d4       	rcall	.+2246   	; 0x18e6 <xTaskCheckForTimeOut>
    1020:	81 11       	cpse	r24, r1
    1022:	13 c0       	rjmp	.+38     	; 0x104a <xQueuePeek+0xe0>
    1024:	c8 01       	movw	r24, r16
    1026:	1f dd       	rcall	.-1474   	; 0xa66 <prvIsQueueEmpty>
    1028:	88 23       	and	r24, r24
    102a:	59 f0       	breq	.+22     	; 0x1042 <xQueuePeek+0xd8>
    102c:	6c 81       	ldd	r22, Y+4	; 0x04
    102e:	7d 81       	ldd	r23, Y+5	; 0x05
    1030:	c7 01       	movw	r24, r14
    1032:	dd d3       	rcall	.+1978   	; 0x17ee <vTaskPlaceOnEventList>
    1034:	c8 01       	movw	r24, r16
    1036:	9a dd       	rcall	.-1228   	; 0xb6c <prvUnlockQueue>
    1038:	a6 d2       	rcall	.+1356   	; 0x1586 <xTaskResumeAll>
    103a:	81 11       	cpse	r24, r1
    103c:	b0 cf       	rjmp	.-160    	; 0xf9e <xQueuePeek+0x34>
    103e:	3a dc       	rcall	.-1932   	; 0x8b4 <vPortYield>
    1040:	ae cf       	rjmp	.-164    	; 0xf9e <xQueuePeek+0x34>
    1042:	c8 01       	movw	r24, r16
    1044:	93 dd       	rcall	.-1242   	; 0xb6c <prvUnlockQueue>
    1046:	9f d2       	rcall	.+1342   	; 0x1586 <xTaskResumeAll>
    1048:	aa cf       	rjmp	.-172    	; 0xf9e <xQueuePeek+0x34>
    104a:	c8 01       	movw	r24, r16
    104c:	8f dd       	rcall	.-1250   	; 0xb6c <prvUnlockQueue>
    104e:	9b d2       	rcall	.+1334   	; 0x1586 <xTaskResumeAll>
    1050:	c8 01       	movw	r24, r16
    1052:	09 dd       	rcall	.-1518   	; 0xa66 <prvIsQueueEmpty>
    1054:	88 23       	and	r24, r24
    1056:	09 f4       	brne	.+2      	; 0x105a <xQueuePeek+0xf0>
    1058:	a2 cf       	rjmp	.-188    	; 0xf9e <xQueuePeek+0x34>
    105a:	80 e0       	ldi	r24, 0x00	; 0
    105c:	0f 90       	pop	r0
    105e:	0f 90       	pop	r0
    1060:	0f 90       	pop	r0
    1062:	0f 90       	pop	r0
    1064:	0f 90       	pop	r0
    1066:	df 91       	pop	r29
    1068:	cf 91       	pop	r28
    106a:	1f 91       	pop	r17
    106c:	0f 91       	pop	r16
    106e:	ff 90       	pop	r15
    1070:	ef 90       	pop	r14
    1072:	df 90       	pop	r13
    1074:	cf 90       	pop	r12
    1076:	bf 90       	pop	r11
    1078:	af 90       	pop	r10
    107a:	08 95       	ret

0000107c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    107c:	cf 93       	push	r28
    107e:	df 93       	push	r29
    1080:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	0f 92       	push	r0
    1088:	8d 8d       	ldd	r24, Y+29	; 0x1d
    108a:	8f 3f       	cpi	r24, 0xFF	; 255
    108c:	09 f4       	brne	.+2      	; 0x1090 <vQueueWaitForMessageRestricted+0x14>
    108e:	1d 8e       	std	Y+29, r1	; 0x1d
    1090:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1092:	8f 3f       	cpi	r24, 0xFF	; 255
    1094:	09 f4       	brne	.+2      	; 0x1098 <vQueueWaitForMessageRestricted+0x1c>
    1096:	1e 8e       	std	Y+30, r1	; 0x1e
    1098:	0f 90       	pop	r0
    109a:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    109c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    109e:	81 11       	cpse	r24, r1
    10a0:	03 c0       	rjmp	.+6      	; 0x10a8 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    10a2:	ce 01       	movw	r24, r28
    10a4:	41 96       	adiw	r24, 0x11	; 17
    10a6:	b4 d3       	rcall	.+1896   	; 0x1810 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    10a8:	ce 01       	movw	r24, r28
    10aa:	60 dd       	rcall	.-1344   	; 0xb6c <prvUnlockQueue>
	}
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	08 95       	ret

000010b2 <prvResetNextTaskUnblockTime>:
    10b2:	e0 91 5d 16 	lds	r30, 0x165D	; 0x80165d <pxDelayedTaskList>
    10b6:	f0 91 5e 16 	lds	r31, 0x165E	; 0x80165e <pxDelayedTaskList+0x1>
    10ba:	80 81       	ld	r24, Z
    10bc:	81 11       	cpse	r24, r1
    10be:	07 c0       	rjmp	.+14     	; 0x10ce <prvResetNextTaskUnblockTime+0x1c>
    10c0:	8f ef       	ldi	r24, 0xFF	; 255
    10c2:	9f ef       	ldi	r25, 0xFF	; 255
    10c4:	90 93 35 16 	sts	0x1635, r25	; 0x801635 <xNextTaskUnblockTime+0x1>
    10c8:	80 93 34 16 	sts	0x1634, r24	; 0x801634 <xNextTaskUnblockTime>
    10cc:	08 95       	ret
    10ce:	e0 91 5d 16 	lds	r30, 0x165D	; 0x80165d <pxDelayedTaskList>
    10d2:	f0 91 5e 16 	lds	r31, 0x165E	; 0x80165e <pxDelayedTaskList+0x1>
    10d6:	05 80       	ldd	r0, Z+5	; 0x05
    10d8:	f6 81       	ldd	r31, Z+6	; 0x06
    10da:	e0 2d       	mov	r30, r0
    10dc:	06 80       	ldd	r0, Z+6	; 0x06
    10de:	f7 81       	ldd	r31, Z+7	; 0x07
    10e0:	e0 2d       	mov	r30, r0
    10e2:	82 81       	ldd	r24, Z+2	; 0x02
    10e4:	93 81       	ldd	r25, Z+3	; 0x03
    10e6:	90 93 35 16 	sts	0x1635, r25	; 0x801635 <xNextTaskUnblockTime+0x1>
    10ea:	80 93 34 16 	sts	0x1634, r24	; 0x801634 <xNextTaskUnblockTime>
    10ee:	08 95       	ret

000010f0 <prvAddCurrentTaskToDelayedList>:
    10f0:	ff 92       	push	r15
    10f2:	0f 93       	push	r16
    10f4:	1f 93       	push	r17
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	ec 01       	movw	r28, r24
    10fc:	f6 2e       	mov	r15, r22
    10fe:	00 91 3c 16 	lds	r16, 0x163C	; 0x80163c <xTickCount>
    1102:	10 91 3d 16 	lds	r17, 0x163D	; 0x80163d <xTickCount+0x1>
    1106:	80 91 95 16 	lds	r24, 0x1695	; 0x801695 <pxCurrentTCB>
    110a:	90 91 96 16 	lds	r25, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    110e:	02 96       	adiw	r24, 0x02	; 2
    1110:	ef da       	rcall	.-2594   	; 0x6f0 <uxListRemove>
    1112:	cf 3f       	cpi	r28, 0xFF	; 255
    1114:	8f ef       	ldi	r24, 0xFF	; 255
    1116:	d8 07       	cpc	r29, r24
    1118:	61 f4       	brne	.+24     	; 0x1132 <prvAddCurrentTaskToDelayedList+0x42>
    111a:	ff 20       	and	r15, r15
    111c:	51 f0       	breq	.+20     	; 0x1132 <prvAddCurrentTaskToDelayedList+0x42>
    111e:	60 91 95 16 	lds	r22, 0x1695	; 0x801695 <pxCurrentTCB>
    1122:	70 91 96 16 	lds	r23, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1126:	6e 5f       	subi	r22, 0xFE	; 254
    1128:	7f 4f       	sbci	r23, 0xFF	; 255
    112a:	8f e3       	ldi	r24, 0x3F	; 63
    112c:	96 e1       	ldi	r25, 0x16	; 22
    112e:	8e da       	rcall	.-2788   	; 0x64c <vListInsertEnd>
    1130:	2d c0       	rjmp	.+90     	; 0x118c <prvAddCurrentTaskToDelayedList+0x9c>
    1132:	c0 0f       	add	r28, r16
    1134:	d1 1f       	adc	r29, r17
    1136:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    113a:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    113e:	d3 83       	std	Z+3, r29	; 0x03
    1140:	c2 83       	std	Z+2, r28	; 0x02
    1142:	c0 17       	cp	r28, r16
    1144:	d1 07       	cpc	r29, r17
    1146:	60 f4       	brcc	.+24     	; 0x1160 <prvAddCurrentTaskToDelayedList+0x70>
    1148:	60 91 95 16 	lds	r22, 0x1695	; 0x801695 <pxCurrentTCB>
    114c:	70 91 96 16 	lds	r23, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1150:	80 91 5b 16 	lds	r24, 0x165B	; 0x80165b <pxOverflowDelayedTaskList>
    1154:	90 91 5c 16 	lds	r25, 0x165C	; 0x80165c <pxOverflowDelayedTaskList+0x1>
    1158:	6e 5f       	subi	r22, 0xFE	; 254
    115a:	7f 4f       	sbci	r23, 0xFF	; 255
    115c:	98 da       	rcall	.-2768   	; 0x68e <vListInsert>
    115e:	16 c0       	rjmp	.+44     	; 0x118c <prvAddCurrentTaskToDelayedList+0x9c>
    1160:	60 91 95 16 	lds	r22, 0x1695	; 0x801695 <pxCurrentTCB>
    1164:	70 91 96 16 	lds	r23, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1168:	80 91 5d 16 	lds	r24, 0x165D	; 0x80165d <pxDelayedTaskList>
    116c:	90 91 5e 16 	lds	r25, 0x165E	; 0x80165e <pxDelayedTaskList+0x1>
    1170:	6e 5f       	subi	r22, 0xFE	; 254
    1172:	7f 4f       	sbci	r23, 0xFF	; 255
    1174:	8c da       	rcall	.-2792   	; 0x68e <vListInsert>
    1176:	80 91 34 16 	lds	r24, 0x1634	; 0x801634 <xNextTaskUnblockTime>
    117a:	90 91 35 16 	lds	r25, 0x1635	; 0x801635 <xNextTaskUnblockTime+0x1>
    117e:	c8 17       	cp	r28, r24
    1180:	d9 07       	cpc	r29, r25
    1182:	20 f4       	brcc	.+8      	; 0x118c <prvAddCurrentTaskToDelayedList+0x9c>
    1184:	d0 93 35 16 	sts	0x1635, r29	; 0x801635 <xNextTaskUnblockTime+0x1>
    1188:	c0 93 34 16 	sts	0x1634, r28	; 0x801634 <xNextTaskUnblockTime>
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	08 95       	ret

00001198 <xTaskCreate>:
    1198:	4f 92       	push	r4
    119a:	5f 92       	push	r5
    119c:	6f 92       	push	r6
    119e:	7f 92       	push	r7
    11a0:	8f 92       	push	r8
    11a2:	9f 92       	push	r9
    11a4:	af 92       	push	r10
    11a6:	bf 92       	push	r11
    11a8:	cf 92       	push	r12
    11aa:	df 92       	push	r13
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	0f 93       	push	r16
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	4c 01       	movw	r8, r24
    11b8:	6b 01       	movw	r12, r22
    11ba:	5a 01       	movw	r10, r20
    11bc:	29 01       	movw	r4, r18
    11be:	ca 01       	movw	r24, r20
    11c0:	32 d9       	rcall	.-3484   	; 0x426 <pvPortMalloc>
    11c2:	3c 01       	movw	r6, r24
    11c4:	89 2b       	or	r24, r25
    11c6:	09 f4       	brne	.+2      	; 0x11ca <xTaskCreate+0x32>
    11c8:	db c0       	rjmp	.+438    	; 0x1380 <xTaskCreate+0x1e8>
    11ca:	88 e2       	ldi	r24, 0x28	; 40
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	2b d9       	rcall	.-3498   	; 0x426 <pvPortMalloc>
    11d0:	ec 01       	movw	r28, r24
    11d2:	89 2b       	or	r24, r25
    11d4:	a9 f0       	breq	.+42     	; 0x1200 <xTaskCreate+0x68>
    11d6:	78 8e       	std	Y+24, r7	; 0x18
    11d8:	6f 8a       	std	Y+23, r6	; 0x17
    11da:	a5 01       	movw	r20, r10
    11dc:	65 ea       	ldi	r22, 0xA5	; 165
    11de:	70 e0       	ldi	r23, 0x00	; 0
    11e0:	c3 01       	movw	r24, r6
    11e2:	21 d6       	rcall	.+3138   	; 0x1e26 <memset>
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	a8 1a       	sub	r10, r24
    11e8:	b1 08       	sbc	r11, r1
    11ea:	8f 89       	ldd	r24, Y+23	; 0x17
    11ec:	98 8d       	ldd	r25, Y+24	; 0x18
    11ee:	a8 0e       	add	r10, r24
    11f0:	b9 1e       	adc	r11, r25
    11f2:	d6 01       	movw	r26, r12
    11f4:	8c 91       	ld	r24, X
    11f6:	89 8f       	std	Y+25, r24	; 0x19
    11f8:	8c 91       	ld	r24, X
    11fa:	81 11       	cpse	r24, r1
    11fc:	04 c0       	rjmp	.+8      	; 0x1206 <xTaskCreate+0x6e>
    11fe:	17 c0       	rjmp	.+46     	; 0x122e <xTaskCreate+0x96>
    1200:	c3 01       	movw	r24, r6
    1202:	ae d9       	rcall	.-3236   	; 0x560 <vPortFree>
    1204:	bd c0       	rjmp	.+378    	; 0x1380 <xTaskCreate+0x1e8>
    1206:	ae 01       	movw	r20, r28
    1208:	46 5e       	subi	r20, 0xE6	; 230
    120a:	5f 4f       	sbci	r21, 0xFF	; 255
    120c:	f6 01       	movw	r30, r12
    120e:	31 96       	adiw	r30, 0x01	; 1
    1210:	b8 e0       	ldi	r27, 0x08	; 8
    1212:	cb 0e       	add	r12, r27
    1214:	d1 1c       	adc	r13, r1
    1216:	cf 01       	movw	r24, r30
    1218:	21 91       	ld	r18, Z+
    121a:	da 01       	movw	r26, r20
    121c:	2d 93       	st	X+, r18
    121e:	ad 01       	movw	r20, r26
    1220:	dc 01       	movw	r26, r24
    1222:	8c 91       	ld	r24, X
    1224:	88 23       	and	r24, r24
    1226:	19 f0       	breq	.+6      	; 0x122e <xTaskCreate+0x96>
    1228:	ec 15       	cp	r30, r12
    122a:	fd 05       	cpc	r31, r13
    122c:	a1 f7       	brne	.-24     	; 0x1216 <xTaskCreate+0x7e>
    122e:	18 a2       	std	Y+32, r1	; 0x20
    1230:	04 30       	cpi	r16, 0x04	; 4
    1232:	08 f0       	brcs	.+2      	; 0x1236 <xTaskCreate+0x9e>
    1234:	03 e0       	ldi	r16, 0x03	; 3
    1236:	0e 8b       	std	Y+22, r16	; 0x16
    1238:	09 a3       	std	Y+33, r16	; 0x21
    123a:	1a a2       	std	Y+34, r1	; 0x22
    123c:	6e 01       	movw	r12, r28
    123e:	b2 e0       	ldi	r27, 0x02	; 2
    1240:	cb 0e       	add	r12, r27
    1242:	d1 1c       	adc	r13, r1
    1244:	c6 01       	movw	r24, r12
    1246:	fe d9       	rcall	.-3076   	; 0x644 <vListInitialiseItem>
    1248:	ce 01       	movw	r24, r28
    124a:	0c 96       	adiw	r24, 0x0c	; 12
    124c:	fb d9       	rcall	.-3082   	; 0x644 <vListInitialiseItem>
    124e:	d9 87       	std	Y+9, r29	; 0x09
    1250:	c8 87       	std	Y+8, r28	; 0x08
    1252:	84 e0       	ldi	r24, 0x04	; 4
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	80 1b       	sub	r24, r16
    1258:	91 09       	sbc	r25, r1
    125a:	9d 87       	std	Y+13, r25	; 0x0d
    125c:	8c 87       	std	Y+12, r24	; 0x0c
    125e:	db 8b       	std	Y+19, r29	; 0x13
    1260:	ca 8b       	std	Y+18, r28	; 0x12
    1262:	1b a2       	std	Y+35, r1	; 0x23
    1264:	1c a2       	std	Y+36, r1	; 0x24
    1266:	1d a2       	std	Y+37, r1	; 0x25
    1268:	1e a2       	std	Y+38, r1	; 0x26
    126a:	1f a2       	std	Y+39, r1	; 0x27
    126c:	a2 01       	movw	r20, r4
    126e:	b4 01       	movw	r22, r8
    1270:	c5 01       	movw	r24, r10
    1272:	65 da       	rcall	.-2870   	; 0x73e <pxPortInitialiseStack>
    1274:	99 83       	std	Y+1, r25	; 0x01
    1276:	88 83       	st	Y, r24
    1278:	e1 14       	cp	r14, r1
    127a:	f1 04       	cpc	r15, r1
    127c:	19 f0       	breq	.+6      	; 0x1284 <xTaskCreate+0xec>
    127e:	f7 01       	movw	r30, r14
    1280:	d1 83       	std	Z+1, r29	; 0x01
    1282:	c0 83       	st	Z, r28
    1284:	0f b6       	in	r0, 0x3f	; 63
    1286:	f8 94       	cli
    1288:	0f 92       	push	r0
    128a:	80 91 3e 16 	lds	r24, 0x163E	; 0x80163e <uxCurrentNumberOfTasks>
    128e:	8f 5f       	subi	r24, 0xFF	; 255
    1290:	80 93 3e 16 	sts	0x163E, r24	; 0x80163e <uxCurrentNumberOfTasks>
    1294:	80 91 95 16 	lds	r24, 0x1695	; 0x801695 <pxCurrentTCB>
    1298:	90 91 96 16 	lds	r25, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    129c:	89 2b       	or	r24, r25
    129e:	89 f5       	brne	.+98     	; 0x1302 <xTaskCreate+0x16a>
    12a0:	d0 93 96 16 	sts	0x1696, r29	; 0x801696 <pxCurrentTCB+0x1>
    12a4:	c0 93 95 16 	sts	0x1695, r28	; 0x801695 <pxCurrentTCB>
    12a8:	80 91 3e 16 	lds	r24, 0x163E	; 0x80163e <uxCurrentNumberOfTasks>
    12ac:	81 30       	cpi	r24, 0x01	; 1
    12ae:	09 f0       	breq	.+2      	; 0x12b2 <xTaskCreate+0x11a>
    12b0:	38 c0       	rjmp	.+112    	; 0x1322 <xTaskCreate+0x18a>
    12b2:	81 e7       	ldi	r24, 0x71	; 113
    12b4:	96 e1       	ldi	r25, 0x16	; 22
    12b6:	b8 d9       	rcall	.-3216   	; 0x628 <vListInitialise>
    12b8:	8a e7       	ldi	r24, 0x7A	; 122
    12ba:	96 e1       	ldi	r25, 0x16	; 22
    12bc:	b5 d9       	rcall	.-3222   	; 0x628 <vListInitialise>
    12be:	83 e8       	ldi	r24, 0x83	; 131
    12c0:	96 e1       	ldi	r25, 0x16	; 22
    12c2:	b2 d9       	rcall	.-3228   	; 0x628 <vListInitialise>
    12c4:	8c e8       	ldi	r24, 0x8C	; 140
    12c6:	96 e1       	ldi	r25, 0x16	; 22
    12c8:	af d9       	rcall	.-3234   	; 0x628 <vListInitialise>
    12ca:	88 e6       	ldi	r24, 0x68	; 104
    12cc:	96 e1       	ldi	r25, 0x16	; 22
    12ce:	ac d9       	rcall	.-3240   	; 0x628 <vListInitialise>
    12d0:	8f e5       	ldi	r24, 0x5F	; 95
    12d2:	96 e1       	ldi	r25, 0x16	; 22
    12d4:	a9 d9       	rcall	.-3246   	; 0x628 <vListInitialise>
    12d6:	82 e5       	ldi	r24, 0x52	; 82
    12d8:	96 e1       	ldi	r25, 0x16	; 22
    12da:	a6 d9       	rcall	.-3252   	; 0x628 <vListInitialise>
    12dc:	89 e4       	ldi	r24, 0x49	; 73
    12de:	96 e1       	ldi	r25, 0x16	; 22
    12e0:	a3 d9       	rcall	.-3258   	; 0x628 <vListInitialise>
    12e2:	8f e3       	ldi	r24, 0x3F	; 63
    12e4:	96 e1       	ldi	r25, 0x16	; 22
    12e6:	a0 d9       	rcall	.-3264   	; 0x628 <vListInitialise>
    12e8:	88 e6       	ldi	r24, 0x68	; 104
    12ea:	96 e1       	ldi	r25, 0x16	; 22
    12ec:	90 93 5e 16 	sts	0x165E, r25	; 0x80165e <pxDelayedTaskList+0x1>
    12f0:	80 93 5d 16 	sts	0x165D, r24	; 0x80165d <pxDelayedTaskList>
    12f4:	8f e5       	ldi	r24, 0x5F	; 95
    12f6:	96 e1       	ldi	r25, 0x16	; 22
    12f8:	90 93 5c 16 	sts	0x165C, r25	; 0x80165c <pxOverflowDelayedTaskList+0x1>
    12fc:	80 93 5b 16 	sts	0x165B, r24	; 0x80165b <pxOverflowDelayedTaskList>
    1300:	10 c0       	rjmp	.+32     	; 0x1322 <xTaskCreate+0x18a>
    1302:	80 91 3a 16 	lds	r24, 0x163A	; 0x80163a <xSchedulerRunning>
    1306:	81 11       	cpse	r24, r1
    1308:	0c c0       	rjmp	.+24     	; 0x1322 <xTaskCreate+0x18a>
    130a:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    130e:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1312:	96 89       	ldd	r25, Z+22	; 0x16
    1314:	8e 89       	ldd	r24, Y+22	; 0x16
    1316:	89 17       	cp	r24, r25
    1318:	20 f0       	brcs	.+8      	; 0x1322 <xTaskCreate+0x18a>
    131a:	d0 93 96 16 	sts	0x1696, r29	; 0x801696 <pxCurrentTCB+0x1>
    131e:	c0 93 95 16 	sts	0x1695, r28	; 0x801695 <pxCurrentTCB>
    1322:	80 91 36 16 	lds	r24, 0x1636	; 0x801636 <uxTaskNumber>
    1326:	8f 5f       	subi	r24, 0xFF	; 255
    1328:	80 93 36 16 	sts	0x1636, r24	; 0x801636 <uxTaskNumber>
    132c:	8e 89       	ldd	r24, Y+22	; 0x16
    132e:	90 91 3b 16 	lds	r25, 0x163B	; 0x80163b <uxTopReadyPriority>
    1332:	98 17       	cp	r25, r24
    1334:	10 f4       	brcc	.+4      	; 0x133a <xTaskCreate+0x1a2>
    1336:	80 93 3b 16 	sts	0x163B, r24	; 0x80163b <uxTopReadyPriority>
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	9c 01       	movw	r18, r24
    133e:	22 0f       	add	r18, r18
    1340:	33 1f       	adc	r19, r19
    1342:	22 0f       	add	r18, r18
    1344:	33 1f       	adc	r19, r19
    1346:	22 0f       	add	r18, r18
    1348:	33 1f       	adc	r19, r19
    134a:	82 0f       	add	r24, r18
    134c:	93 1f       	adc	r25, r19
    134e:	b6 01       	movw	r22, r12
    1350:	8f 58       	subi	r24, 0x8F	; 143
    1352:	99 4e       	sbci	r25, 0xE9	; 233
    1354:	7b d9       	rcall	.-3338   	; 0x64c <vListInsertEnd>
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	80 91 3a 16 	lds	r24, 0x163A	; 0x80163a <xSchedulerRunning>
    135e:	88 23       	and	r24, r24
    1360:	59 f0       	breq	.+22     	; 0x1378 <xTaskCreate+0x1e0>
    1362:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    1366:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    136a:	96 89       	ldd	r25, Z+22	; 0x16
    136c:	8e 89       	ldd	r24, Y+22	; 0x16
    136e:	98 17       	cp	r25, r24
    1370:	28 f4       	brcc	.+10     	; 0x137c <xTaskCreate+0x1e4>
    1372:	a0 da       	rcall	.-2752   	; 0x8b4 <vPortYield>
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	05 c0       	rjmp	.+10     	; 0x1382 <xTaskCreate+0x1ea>
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	03 c0       	rjmp	.+6      	; 0x1382 <xTaskCreate+0x1ea>
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	01 c0       	rjmp	.+2      	; 0x1382 <xTaskCreate+0x1ea>
    1380:	8f ef       	ldi	r24, 0xFF	; 255
    1382:	df 91       	pop	r29
    1384:	cf 91       	pop	r28
    1386:	0f 91       	pop	r16
    1388:	ff 90       	pop	r15
    138a:	ef 90       	pop	r14
    138c:	df 90       	pop	r13
    138e:	cf 90       	pop	r12
    1390:	bf 90       	pop	r11
    1392:	af 90       	pop	r10
    1394:	9f 90       	pop	r9
    1396:	8f 90       	pop	r8
    1398:	7f 90       	pop	r7
    139a:	6f 90       	pop	r6
    139c:	5f 90       	pop	r5
    139e:	4f 90       	pop	r4
    13a0:	08 95       	ret

000013a2 <vTaskStartScheduler>:
    13a2:	ef 92       	push	r14
    13a4:	ff 92       	push	r15
    13a6:	0f 93       	push	r16
    13a8:	0f 2e       	mov	r0, r31
    13aa:	f2 e3       	ldi	r31, 0x32	; 50
    13ac:	ef 2e       	mov	r14, r31
    13ae:	f6 e1       	ldi	r31, 0x16	; 22
    13b0:	ff 2e       	mov	r15, r31
    13b2:	f0 2d       	mov	r31, r0
    13b4:	00 e0       	ldi	r16, 0x00	; 0
    13b6:	20 e0       	ldi	r18, 0x00	; 0
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	40 e2       	ldi	r20, 0x20	; 32
    13bc:	53 e0       	ldi	r21, 0x03	; 3
    13be:	6b e1       	ldi	r22, 0x1B	; 27
    13c0:	74 e0       	ldi	r23, 0x04	; 4
    13c2:	8c e7       	ldi	r24, 0x7C	; 124
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	e8 de       	rcall	.-560    	; 0x1198 <xTaskCreate>
    13c8:	81 30       	cpi	r24, 0x01	; 1
    13ca:	91 f4       	brne	.+36     	; 0x13f0 <vTaskStartScheduler+0x4e>
    13cc:	6a d3       	rcall	.+1748   	; 0x1aa2 <xTimerCreateTimerTask>
    13ce:	81 30       	cpi	r24, 0x01	; 1
    13d0:	79 f4       	brne	.+30     	; 0x13f0 <vTaskStartScheduler+0x4e>
    13d2:	f8 94       	cli
    13d4:	8f ef       	ldi	r24, 0xFF	; 255
    13d6:	9f ef       	ldi	r25, 0xFF	; 255
    13d8:	90 93 35 16 	sts	0x1635, r25	; 0x801635 <xNextTaskUnblockTime+0x1>
    13dc:	80 93 34 16 	sts	0x1634, r24	; 0x801634 <xNextTaskUnblockTime>
    13e0:	81 e0       	ldi	r24, 0x01	; 1
    13e2:	80 93 3a 16 	sts	0x163A, r24	; 0x80163a <xSchedulerRunning>
    13e6:	10 92 3d 16 	sts	0x163D, r1	; 0x80163d <xTickCount+0x1>
    13ea:	10 92 3c 16 	sts	0x163C, r1	; 0x80163c <xTickCount>
    13ee:	19 da       	rcall	.-3022   	; 0x822 <xPortStartScheduler>
    13f0:	0f 91       	pop	r16
    13f2:	ff 90       	pop	r15
    13f4:	ef 90       	pop	r14
    13f6:	08 95       	ret

000013f8 <vTaskSuspendAll>:
    13f8:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    13fc:	8f 5f       	subi	r24, 0xFF	; 255
    13fe:	80 93 31 16 	sts	0x1631, r24	; 0x801631 <uxSchedulerSuspended>
    1402:	08 95       	ret

00001404 <xTaskGetTickCount>:
    1404:	0f b6       	in	r0, 0x3f	; 63
    1406:	f8 94       	cli
    1408:	0f 92       	push	r0
    140a:	80 91 3c 16 	lds	r24, 0x163C	; 0x80163c <xTickCount>
    140e:	90 91 3d 16 	lds	r25, 0x163D	; 0x80163d <xTickCount+0x1>
    1412:	0f 90       	pop	r0
    1414:	0f be       	out	0x3f, r0	; 63
    1416:	08 95       	ret

00001418 <xTaskIncrementTick>:
    1418:	cf 92       	push	r12
    141a:	df 92       	push	r13
    141c:	ef 92       	push	r14
    141e:	ff 92       	push	r15
    1420:	0f 93       	push	r16
    1422:	1f 93       	push	r17
    1424:	cf 93       	push	r28
    1426:	df 93       	push	r29
    1428:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    142c:	81 11       	cpse	r24, r1
    142e:	95 c0       	rjmp	.+298    	; 0x155a <xTaskIncrementTick+0x142>
    1430:	e0 90 3c 16 	lds	r14, 0x163C	; 0x80163c <xTickCount>
    1434:	f0 90 3d 16 	lds	r15, 0x163D	; 0x80163d <xTickCount+0x1>
    1438:	8f ef       	ldi	r24, 0xFF	; 255
    143a:	e8 1a       	sub	r14, r24
    143c:	f8 0a       	sbc	r15, r24
    143e:	f0 92 3d 16 	sts	0x163D, r15	; 0x80163d <xTickCount+0x1>
    1442:	e0 92 3c 16 	sts	0x163C, r14	; 0x80163c <xTickCount>
    1446:	e1 14       	cp	r14, r1
    1448:	f1 04       	cpc	r15, r1
    144a:	b1 f4       	brne	.+44     	; 0x1478 <xTaskIncrementTick+0x60>
    144c:	80 91 5d 16 	lds	r24, 0x165D	; 0x80165d <pxDelayedTaskList>
    1450:	90 91 5e 16 	lds	r25, 0x165E	; 0x80165e <pxDelayedTaskList+0x1>
    1454:	20 91 5b 16 	lds	r18, 0x165B	; 0x80165b <pxOverflowDelayedTaskList>
    1458:	30 91 5c 16 	lds	r19, 0x165C	; 0x80165c <pxOverflowDelayedTaskList+0x1>
    145c:	30 93 5e 16 	sts	0x165E, r19	; 0x80165e <pxDelayedTaskList+0x1>
    1460:	20 93 5d 16 	sts	0x165D, r18	; 0x80165d <pxDelayedTaskList>
    1464:	90 93 5c 16 	sts	0x165C, r25	; 0x80165c <pxOverflowDelayedTaskList+0x1>
    1468:	80 93 5b 16 	sts	0x165B, r24	; 0x80165b <pxOverflowDelayedTaskList>
    146c:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <xNumOfOverflows>
    1470:	8f 5f       	subi	r24, 0xFF	; 255
    1472:	80 93 37 16 	sts	0x1637, r24	; 0x801637 <xNumOfOverflows>
    1476:	1d de       	rcall	.-966    	; 0x10b2 <prvResetNextTaskUnblockTime>
    1478:	80 91 34 16 	lds	r24, 0x1634	; 0x801634 <xNextTaskUnblockTime>
    147c:	90 91 35 16 	lds	r25, 0x1635	; 0x801635 <xNextTaskUnblockTime+0x1>
    1480:	e8 16       	cp	r14, r24
    1482:	f9 06       	cpc	r15, r25
    1484:	10 f4       	brcc	.+4      	; 0x148a <xTaskIncrementTick+0x72>
    1486:	d1 2c       	mov	r13, r1
    1488:	50 c0       	rjmp	.+160    	; 0x152a <xTaskIncrementTick+0x112>
    148a:	d1 2c       	mov	r13, r1
    148c:	cc 24       	eor	r12, r12
    148e:	c3 94       	inc	r12
    1490:	e0 91 5d 16 	lds	r30, 0x165D	; 0x80165d <pxDelayedTaskList>
    1494:	f0 91 5e 16 	lds	r31, 0x165E	; 0x80165e <pxDelayedTaskList+0x1>
    1498:	80 81       	ld	r24, Z
    149a:	81 11       	cpse	r24, r1
    149c:	07 c0       	rjmp	.+14     	; 0x14ac <xTaskIncrementTick+0x94>
    149e:	8f ef       	ldi	r24, 0xFF	; 255
    14a0:	9f ef       	ldi	r25, 0xFF	; 255
    14a2:	90 93 35 16 	sts	0x1635, r25	; 0x801635 <xNextTaskUnblockTime+0x1>
    14a6:	80 93 34 16 	sts	0x1634, r24	; 0x801634 <xNextTaskUnblockTime>
    14aa:	3f c0       	rjmp	.+126    	; 0x152a <xTaskIncrementTick+0x112>
    14ac:	e0 91 5d 16 	lds	r30, 0x165D	; 0x80165d <pxDelayedTaskList>
    14b0:	f0 91 5e 16 	lds	r31, 0x165E	; 0x80165e <pxDelayedTaskList+0x1>
    14b4:	05 80       	ldd	r0, Z+5	; 0x05
    14b6:	f6 81       	ldd	r31, Z+6	; 0x06
    14b8:	e0 2d       	mov	r30, r0
    14ba:	c6 81       	ldd	r28, Z+6	; 0x06
    14bc:	d7 81       	ldd	r29, Z+7	; 0x07
    14be:	8a 81       	ldd	r24, Y+2	; 0x02
    14c0:	9b 81       	ldd	r25, Y+3	; 0x03
    14c2:	e8 16       	cp	r14, r24
    14c4:	f9 06       	cpc	r15, r25
    14c6:	28 f4       	brcc	.+10     	; 0x14d2 <xTaskIncrementTick+0xba>
    14c8:	90 93 35 16 	sts	0x1635, r25	; 0x801635 <xNextTaskUnblockTime+0x1>
    14cc:	80 93 34 16 	sts	0x1634, r24	; 0x801634 <xNextTaskUnblockTime>
    14d0:	2c c0       	rjmp	.+88     	; 0x152a <xTaskIncrementTick+0x112>
    14d2:	8e 01       	movw	r16, r28
    14d4:	0e 5f       	subi	r16, 0xFE	; 254
    14d6:	1f 4f       	sbci	r17, 0xFF	; 255
    14d8:	c8 01       	movw	r24, r16
    14da:	0a d9       	rcall	.-3564   	; 0x6f0 <uxListRemove>
    14dc:	8c 89       	ldd	r24, Y+20	; 0x14
    14de:	9d 89       	ldd	r25, Y+21	; 0x15
    14e0:	89 2b       	or	r24, r25
    14e2:	19 f0       	breq	.+6      	; 0x14ea <xTaskIncrementTick+0xd2>
    14e4:	ce 01       	movw	r24, r28
    14e6:	0c 96       	adiw	r24, 0x0c	; 12
    14e8:	03 d9       	rcall	.-3578   	; 0x6f0 <uxListRemove>
    14ea:	8e 89       	ldd	r24, Y+22	; 0x16
    14ec:	90 91 3b 16 	lds	r25, 0x163B	; 0x80163b <uxTopReadyPriority>
    14f0:	98 17       	cp	r25, r24
    14f2:	10 f4       	brcc	.+4      	; 0x14f8 <xTaskIncrementTick+0xe0>
    14f4:	80 93 3b 16 	sts	0x163B, r24	; 0x80163b <uxTopReadyPriority>
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	9c 01       	movw	r18, r24
    14fc:	22 0f       	add	r18, r18
    14fe:	33 1f       	adc	r19, r19
    1500:	22 0f       	add	r18, r18
    1502:	33 1f       	adc	r19, r19
    1504:	22 0f       	add	r18, r18
    1506:	33 1f       	adc	r19, r19
    1508:	82 0f       	add	r24, r18
    150a:	93 1f       	adc	r25, r19
    150c:	b8 01       	movw	r22, r16
    150e:	8f 58       	subi	r24, 0x8F	; 143
    1510:	99 4e       	sbci	r25, 0xE9	; 233
    1512:	9c d8       	rcall	.-3784   	; 0x64c <vListInsertEnd>
    1514:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    1518:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    151c:	9e 89       	ldd	r25, Y+22	; 0x16
    151e:	86 89       	ldd	r24, Z+22	; 0x16
    1520:	98 17       	cp	r25, r24
    1522:	08 f4       	brcc	.+2      	; 0x1526 <xTaskIncrementTick+0x10e>
    1524:	b5 cf       	rjmp	.-150    	; 0x1490 <xTaskIncrementTick+0x78>
    1526:	dc 2c       	mov	r13, r12
    1528:	b3 cf       	rjmp	.-154    	; 0x1490 <xTaskIncrementTick+0x78>
    152a:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    152e:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1532:	86 89       	ldd	r24, Z+22	; 0x16
    1534:	90 e0       	ldi	r25, 0x00	; 0
    1536:	fc 01       	movw	r30, r24
    1538:	ee 0f       	add	r30, r30
    153a:	ff 1f       	adc	r31, r31
    153c:	ee 0f       	add	r30, r30
    153e:	ff 1f       	adc	r31, r31
    1540:	ee 0f       	add	r30, r30
    1542:	ff 1f       	adc	r31, r31
    1544:	8e 0f       	add	r24, r30
    1546:	9f 1f       	adc	r25, r31
    1548:	fc 01       	movw	r30, r24
    154a:	ef 58       	subi	r30, 0x8F	; 143
    154c:	f9 4e       	sbci	r31, 0xE9	; 233
    154e:	80 81       	ld	r24, Z
    1550:	82 30       	cpi	r24, 0x02	; 2
    1552:	48 f0       	brcs	.+18     	; 0x1566 <xTaskIncrementTick+0x14e>
    1554:	dd 24       	eor	r13, r13
    1556:	d3 94       	inc	r13
    1558:	06 c0       	rjmp	.+12     	; 0x1566 <xTaskIncrementTick+0x14e>
    155a:	80 91 39 16 	lds	r24, 0x1639	; 0x801639 <uxPendedTicks>
    155e:	8f 5f       	subi	r24, 0xFF	; 255
    1560:	80 93 39 16 	sts	0x1639, r24	; 0x801639 <uxPendedTicks>
    1564:	d1 2c       	mov	r13, r1
    1566:	80 91 38 16 	lds	r24, 0x1638	; 0x801638 <xYieldPending>
    156a:	88 23       	and	r24, r24
    156c:	11 f0       	breq	.+4      	; 0x1572 <xTaskIncrementTick+0x15a>
    156e:	dd 24       	eor	r13, r13
    1570:	d3 94       	inc	r13
    1572:	8d 2d       	mov	r24, r13
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	1f 91       	pop	r17
    157a:	0f 91       	pop	r16
    157c:	ff 90       	pop	r15
    157e:	ef 90       	pop	r14
    1580:	df 90       	pop	r13
    1582:	cf 90       	pop	r12
    1584:	08 95       	ret

00001586 <xTaskResumeAll>:
    1586:	df 92       	push	r13
    1588:	ef 92       	push	r14
    158a:	ff 92       	push	r15
    158c:	0f 93       	push	r16
    158e:	1f 93       	push	r17
    1590:	cf 93       	push	r28
    1592:	df 93       	push	r29
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	0f 92       	push	r0
    159a:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    159e:	81 50       	subi	r24, 0x01	; 1
    15a0:	80 93 31 16 	sts	0x1631, r24	; 0x801631 <uxSchedulerSuspended>
    15a4:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    15a8:	81 11       	cpse	r24, r1
    15aa:	59 c0       	rjmp	.+178    	; 0x165e <xTaskResumeAll+0xd8>
    15ac:	80 91 3e 16 	lds	r24, 0x163E	; 0x80163e <uxCurrentNumberOfTasks>
    15b0:	81 11       	cpse	r24, r1
    15b2:	30 c0       	rjmp	.+96     	; 0x1614 <xTaskResumeAll+0x8e>
    15b4:	57 c0       	rjmp	.+174    	; 0x1664 <xTaskResumeAll+0xde>
    15b6:	d7 01       	movw	r26, r14
    15b8:	15 96       	adiw	r26, 0x05	; 5
    15ba:	ed 91       	ld	r30, X+
    15bc:	fc 91       	ld	r31, X
    15be:	16 97       	sbiw	r26, 0x06	; 6
    15c0:	c6 81       	ldd	r28, Z+6	; 0x06
    15c2:	d7 81       	ldd	r29, Z+7	; 0x07
    15c4:	ce 01       	movw	r24, r28
    15c6:	0c 96       	adiw	r24, 0x0c	; 12
    15c8:	93 d8       	rcall	.-3802   	; 0x6f0 <uxListRemove>
    15ca:	8e 01       	movw	r16, r28
    15cc:	0e 5f       	subi	r16, 0xFE	; 254
    15ce:	1f 4f       	sbci	r17, 0xFF	; 255
    15d0:	c8 01       	movw	r24, r16
    15d2:	8e d8       	rcall	.-3812   	; 0x6f0 <uxListRemove>
    15d4:	8e 89       	ldd	r24, Y+22	; 0x16
    15d6:	90 91 3b 16 	lds	r25, 0x163B	; 0x80163b <uxTopReadyPriority>
    15da:	98 17       	cp	r25, r24
    15dc:	10 f4       	brcc	.+4      	; 0x15e2 <xTaskResumeAll+0x5c>
    15de:	80 93 3b 16 	sts	0x163B, r24	; 0x80163b <uxTopReadyPriority>
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	9c 01       	movw	r18, r24
    15e6:	22 0f       	add	r18, r18
    15e8:	33 1f       	adc	r19, r19
    15ea:	22 0f       	add	r18, r18
    15ec:	33 1f       	adc	r19, r19
    15ee:	22 0f       	add	r18, r18
    15f0:	33 1f       	adc	r19, r19
    15f2:	82 0f       	add	r24, r18
    15f4:	93 1f       	adc	r25, r19
    15f6:	b8 01       	movw	r22, r16
    15f8:	8f 58       	subi	r24, 0x8F	; 143
    15fa:	99 4e       	sbci	r25, 0xE9	; 233
    15fc:	27 d8       	rcall	.-4018   	; 0x64c <vListInsertEnd>
    15fe:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    1602:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1606:	9e 89       	ldd	r25, Y+22	; 0x16
    1608:	86 89       	ldd	r24, Z+22	; 0x16
    160a:	98 17       	cp	r25, r24
    160c:	68 f0       	brcs	.+26     	; 0x1628 <xTaskResumeAll+0xa2>
    160e:	d0 92 38 16 	sts	0x1638, r13	; 0x801638 <xYieldPending>
    1612:	0a c0       	rjmp	.+20     	; 0x1628 <xTaskResumeAll+0xa2>
    1614:	c0 e0       	ldi	r28, 0x00	; 0
    1616:	d0 e0       	ldi	r29, 0x00	; 0
    1618:	0f 2e       	mov	r0, r31
    161a:	f2 e5       	ldi	r31, 0x52	; 82
    161c:	ef 2e       	mov	r14, r31
    161e:	f6 e1       	ldi	r31, 0x16	; 22
    1620:	ff 2e       	mov	r15, r31
    1622:	f0 2d       	mov	r31, r0
    1624:	dd 24       	eor	r13, r13
    1626:	d3 94       	inc	r13
    1628:	f7 01       	movw	r30, r14
    162a:	80 81       	ld	r24, Z
    162c:	81 11       	cpse	r24, r1
    162e:	c3 cf       	rjmp	.-122    	; 0x15b6 <xTaskResumeAll+0x30>
    1630:	cd 2b       	or	r28, r29
    1632:	09 f0       	breq	.+2      	; 0x1636 <xTaskResumeAll+0xb0>
    1634:	3e dd       	rcall	.-1412   	; 0x10b2 <prvResetNextTaskUnblockTime>
    1636:	c0 91 39 16 	lds	r28, 0x1639	; 0x801639 <uxPendedTicks>
    163a:	cc 23       	and	r28, r28
    163c:	49 f0       	breq	.+18     	; 0x1650 <xTaskResumeAll+0xca>
    163e:	d1 e0       	ldi	r29, 0x01	; 1
    1640:	eb de       	rcall	.-554    	; 0x1418 <xTaskIncrementTick>
    1642:	81 11       	cpse	r24, r1
    1644:	d0 93 38 16 	sts	0x1638, r29	; 0x801638 <xYieldPending>
    1648:	c1 50       	subi	r28, 0x01	; 1
    164a:	d1 f7       	brne	.-12     	; 0x1640 <xTaskResumeAll+0xba>
    164c:	10 92 39 16 	sts	0x1639, r1	; 0x801639 <uxPendedTicks>
    1650:	80 91 38 16 	lds	r24, 0x1638	; 0x801638 <xYieldPending>
    1654:	88 23       	and	r24, r24
    1656:	29 f0       	breq	.+10     	; 0x1662 <xTaskResumeAll+0xdc>
    1658:	2d d9       	rcall	.-3494   	; 0x8b4 <vPortYield>
    165a:	81 e0       	ldi	r24, 0x01	; 1
    165c:	03 c0       	rjmp	.+6      	; 0x1664 <xTaskResumeAll+0xde>
    165e:	80 e0       	ldi	r24, 0x00	; 0
    1660:	01 c0       	rjmp	.+2      	; 0x1664 <xTaskResumeAll+0xde>
    1662:	80 e0       	ldi	r24, 0x00	; 0
    1664:	0f 90       	pop	r0
    1666:	0f be       	out	0x3f, r0	; 63
    1668:	df 91       	pop	r29
    166a:	cf 91       	pop	r28
    166c:	1f 91       	pop	r17
    166e:	0f 91       	pop	r16
    1670:	ff 90       	pop	r15
    1672:	ef 90       	pop	r14
    1674:	df 90       	pop	r13
    1676:	08 95       	ret

00001678 <vTaskDelayUntil>:
    1678:	0f 93       	push	r16
    167a:	1f 93       	push	r17
    167c:	cf 93       	push	r28
    167e:	df 93       	push	r29
    1680:	8c 01       	movw	r16, r24
    1682:	eb 01       	movw	r28, r22
    1684:	b9 de       	rcall	.-654    	; 0x13f8 <vTaskSuspendAll>
    1686:	40 91 3c 16 	lds	r20, 0x163C	; 0x80163c <xTickCount>
    168a:	50 91 3d 16 	lds	r21, 0x163D	; 0x80163d <xTickCount+0x1>
    168e:	f8 01       	movw	r30, r16
    1690:	20 81       	ld	r18, Z
    1692:	31 81       	ldd	r19, Z+1	; 0x01
    1694:	c9 01       	movw	r24, r18
    1696:	8c 0f       	add	r24, r28
    1698:	9d 1f       	adc	r25, r29
    169a:	42 17       	cp	r20, r18
    169c:	53 07       	cpc	r21, r19
    169e:	48 f4       	brcc	.+18     	; 0x16b2 <vTaskDelayUntil+0x3a>
    16a0:	82 17       	cp	r24, r18
    16a2:	93 07       	cpc	r25, r19
    16a4:	d0 f4       	brcc	.+52     	; 0x16da <vTaskDelayUntil+0x62>
    16a6:	91 83       	std	Z+1, r25	; 0x01
    16a8:	80 83       	st	Z, r24
    16aa:	48 17       	cp	r20, r24
    16ac:	59 07       	cpc	r21, r25
    16ae:	60 f4       	brcc	.+24     	; 0x16c8 <vTaskDelayUntil+0x50>
    16b0:	07 c0       	rjmp	.+14     	; 0x16c0 <vTaskDelayUntil+0x48>
    16b2:	82 17       	cp	r24, r18
    16b4:	93 07       	cpc	r25, r19
    16b6:	68 f0       	brcs	.+26     	; 0x16d2 <vTaskDelayUntil+0x5a>
    16b8:	48 17       	cp	r20, r24
    16ba:	59 07       	cpc	r21, r25
    16bc:	50 f0       	brcs	.+20     	; 0x16d2 <vTaskDelayUntil+0x5a>
    16be:	0d c0       	rjmp	.+26     	; 0x16da <vTaskDelayUntil+0x62>
    16c0:	60 e0       	ldi	r22, 0x00	; 0
    16c2:	84 1b       	sub	r24, r20
    16c4:	95 0b       	sbc	r25, r21
    16c6:	14 dd       	rcall	.-1496   	; 0x10f0 <prvAddCurrentTaskToDelayedList>
    16c8:	5e df       	rcall	.-324    	; 0x1586 <xTaskResumeAll>
    16ca:	81 11       	cpse	r24, r1
    16cc:	0a c0       	rjmp	.+20     	; 0x16e2 <vTaskDelayUntil+0x6a>
    16ce:	f2 d8       	rcall	.-3612   	; 0x8b4 <vPortYield>
    16d0:	08 c0       	rjmp	.+16     	; 0x16e2 <vTaskDelayUntil+0x6a>
    16d2:	f8 01       	movw	r30, r16
    16d4:	91 83       	std	Z+1, r25	; 0x01
    16d6:	80 83       	st	Z, r24
    16d8:	f3 cf       	rjmp	.-26     	; 0x16c0 <vTaskDelayUntil+0x48>
    16da:	f8 01       	movw	r30, r16
    16dc:	91 83       	std	Z+1, r25	; 0x01
    16de:	80 83       	st	Z, r24
    16e0:	f3 cf       	rjmp	.-26     	; 0x16c8 <vTaskDelayUntil+0x50>
    16e2:	df 91       	pop	r29
    16e4:	cf 91       	pop	r28
    16e6:	1f 91       	pop	r17
    16e8:	0f 91       	pop	r16
    16ea:	08 95       	ret

000016ec <vTaskSwitchContext>:
    16ec:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    16f0:	88 23       	and	r24, r24
    16f2:	21 f0       	breq	.+8      	; 0x16fc <vTaskSwitchContext+0x10>
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	80 93 38 16 	sts	0x1638, r24	; 0x801638 <xYieldPending>
    16fa:	08 95       	ret
    16fc:	10 92 38 16 	sts	0x1638, r1	; 0x801638 <xYieldPending>
    1700:	a0 91 95 16 	lds	r26, 0x1695	; 0x801695 <pxCurrentTCB>
    1704:	b0 91 96 16 	lds	r27, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1708:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    170c:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1710:	2d 91       	ld	r18, X+
    1712:	3c 91       	ld	r19, X
    1714:	87 89       	ldd	r24, Z+23	; 0x17
    1716:	90 8d       	ldd	r25, Z+24	; 0x18
    1718:	82 17       	cp	r24, r18
    171a:	93 07       	cpc	r25, r19
    171c:	60 f0       	brcs	.+24     	; 0x1736 <vTaskSwitchContext+0x4a>
    171e:	60 91 95 16 	lds	r22, 0x1695	; 0x801695 <pxCurrentTCB>
    1722:	70 91 96 16 	lds	r23, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1726:	80 91 95 16 	lds	r24, 0x1695	; 0x801695 <pxCurrentTCB>
    172a:	90 91 96 16 	lds	r25, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    172e:	67 5e       	subi	r22, 0xE7	; 231
    1730:	7f 4f       	sbci	r23, 0xFF	; 255
    1732:	0e 94 07 03 	call	0x60e	; 0x60e <vApplicationStackOverflowHook>
    1736:	20 91 3b 16 	lds	r18, 0x163B	; 0x80163b <uxTopReadyPriority>
    173a:	82 2f       	mov	r24, r18
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	fc 01       	movw	r30, r24
    1740:	ee 0f       	add	r30, r30
    1742:	ff 1f       	adc	r31, r31
    1744:	ee 0f       	add	r30, r30
    1746:	ff 1f       	adc	r31, r31
    1748:	ee 0f       	add	r30, r30
    174a:	ff 1f       	adc	r31, r31
    174c:	e8 0f       	add	r30, r24
    174e:	f9 1f       	adc	r31, r25
    1750:	ef 58       	subi	r30, 0x8F	; 143
    1752:	f9 4e       	sbci	r31, 0xE9	; 233
    1754:	30 81       	ld	r19, Z
    1756:	31 11       	cpse	r19, r1
    1758:	11 c0       	rjmp	.+34     	; 0x177c <vTaskSwitchContext+0x90>
    175a:	21 50       	subi	r18, 0x01	; 1
    175c:	82 2f       	mov	r24, r18
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	fc 01       	movw	r30, r24
    1762:	ee 0f       	add	r30, r30
    1764:	ff 1f       	adc	r31, r31
    1766:	ee 0f       	add	r30, r30
    1768:	ff 1f       	adc	r31, r31
    176a:	ee 0f       	add	r30, r30
    176c:	ff 1f       	adc	r31, r31
    176e:	e8 0f       	add	r30, r24
    1770:	f9 1f       	adc	r31, r25
    1772:	ef 58       	subi	r30, 0x8F	; 143
    1774:	f9 4e       	sbci	r31, 0xE9	; 233
    1776:	30 81       	ld	r19, Z
    1778:	33 23       	and	r19, r19
    177a:	79 f3       	breq	.-34     	; 0x175a <vTaskSwitchContext+0x6e>
    177c:	ac 01       	movw	r20, r24
    177e:	44 0f       	add	r20, r20
    1780:	55 1f       	adc	r21, r21
    1782:	44 0f       	add	r20, r20
    1784:	55 1f       	adc	r21, r21
    1786:	44 0f       	add	r20, r20
    1788:	55 1f       	adc	r21, r21
    178a:	48 0f       	add	r20, r24
    178c:	59 1f       	adc	r21, r25
    178e:	da 01       	movw	r26, r20
    1790:	af 58       	subi	r26, 0x8F	; 143
    1792:	b9 4e       	sbci	r27, 0xE9	; 233
    1794:	11 96       	adiw	r26, 0x01	; 1
    1796:	ed 91       	ld	r30, X+
    1798:	fc 91       	ld	r31, X
    179a:	12 97       	sbiw	r26, 0x02	; 2
    179c:	02 80       	ldd	r0, Z+2	; 0x02
    179e:	f3 81       	ldd	r31, Z+3	; 0x03
    17a0:	e0 2d       	mov	r30, r0
    17a2:	12 96       	adiw	r26, 0x02	; 2
    17a4:	fc 93       	st	X, r31
    17a6:	ee 93       	st	-X, r30
    17a8:	11 97       	sbiw	r26, 0x01	; 1
    17aa:	4c 58       	subi	r20, 0x8C	; 140
    17ac:	59 4e       	sbci	r21, 0xE9	; 233
    17ae:	e4 17       	cp	r30, r20
    17b0:	f5 07       	cpc	r31, r21
    17b2:	29 f4       	brne	.+10     	; 0x17be <vTaskSwitchContext+0xd2>
    17b4:	42 81       	ldd	r20, Z+2	; 0x02
    17b6:	53 81       	ldd	r21, Z+3	; 0x03
    17b8:	fd 01       	movw	r30, r26
    17ba:	52 83       	std	Z+2, r21	; 0x02
    17bc:	41 83       	std	Z+1, r20	; 0x01
    17be:	fc 01       	movw	r30, r24
    17c0:	ee 0f       	add	r30, r30
    17c2:	ff 1f       	adc	r31, r31
    17c4:	ee 0f       	add	r30, r30
    17c6:	ff 1f       	adc	r31, r31
    17c8:	ee 0f       	add	r30, r30
    17ca:	ff 1f       	adc	r31, r31
    17cc:	8e 0f       	add	r24, r30
    17ce:	9f 1f       	adc	r25, r31
    17d0:	fc 01       	movw	r30, r24
    17d2:	ef 58       	subi	r30, 0x8F	; 143
    17d4:	f9 4e       	sbci	r31, 0xE9	; 233
    17d6:	01 80       	ldd	r0, Z+1	; 0x01
    17d8:	f2 81       	ldd	r31, Z+2	; 0x02
    17da:	e0 2d       	mov	r30, r0
    17dc:	86 81       	ldd	r24, Z+6	; 0x06
    17de:	97 81       	ldd	r25, Z+7	; 0x07
    17e0:	90 93 96 16 	sts	0x1696, r25	; 0x801696 <pxCurrentTCB+0x1>
    17e4:	80 93 95 16 	sts	0x1695, r24	; 0x801695 <pxCurrentTCB>
    17e8:	20 93 3b 16 	sts	0x163B, r18	; 0x80163b <uxTopReadyPriority>
    17ec:	08 95       	ret

000017ee <vTaskPlaceOnEventList>:
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
    17f2:	eb 01       	movw	r28, r22
    17f4:	60 91 95 16 	lds	r22, 0x1695	; 0x801695 <pxCurrentTCB>
    17f8:	70 91 96 16 	lds	r23, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    17fc:	64 5f       	subi	r22, 0xF4	; 244
    17fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1800:	0e 94 47 03 	call	0x68e	; 0x68e <vListInsert>
    1804:	61 e0       	ldi	r22, 0x01	; 1
    1806:	ce 01       	movw	r24, r28
    1808:	73 dc       	rcall	.-1818   	; 0x10f0 <prvAddCurrentTaskToDelayedList>
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	08 95       	ret

00001810 <vTaskPlaceOnEventListRestricted>:
    1810:	0f 93       	push	r16
    1812:	1f 93       	push	r17
    1814:	cf 93       	push	r28
    1816:	8b 01       	movw	r16, r22
    1818:	c4 2f       	mov	r28, r20
    181a:	60 91 95 16 	lds	r22, 0x1695	; 0x801695 <pxCurrentTCB>
    181e:	70 91 96 16 	lds	r23, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    1822:	64 5f       	subi	r22, 0xF4	; 244
    1824:	7f 4f       	sbci	r23, 0xFF	; 255
    1826:	0e 94 26 03 	call	0x64c	; 0x64c <vListInsertEnd>
    182a:	cc 23       	and	r28, r28
    182c:	11 f0       	breq	.+4      	; 0x1832 <vTaskPlaceOnEventListRestricted+0x22>
    182e:	0f ef       	ldi	r16, 0xFF	; 255
    1830:	1f ef       	ldi	r17, 0xFF	; 255
    1832:	6c 2f       	mov	r22, r28
    1834:	c8 01       	movw	r24, r16
    1836:	5c dc       	rcall	.-1864   	; 0x10f0 <prvAddCurrentTaskToDelayedList>
    1838:	cf 91       	pop	r28
    183a:	1f 91       	pop	r17
    183c:	0f 91       	pop	r16
    183e:	08 95       	ret

00001840 <xTaskRemoveFromEventList>:
    1840:	0f 93       	push	r16
    1842:	1f 93       	push	r17
    1844:	cf 93       	push	r28
    1846:	df 93       	push	r29
    1848:	dc 01       	movw	r26, r24
    184a:	15 96       	adiw	r26, 0x05	; 5
    184c:	ed 91       	ld	r30, X+
    184e:	fc 91       	ld	r31, X
    1850:	16 97       	sbiw	r26, 0x06	; 6
    1852:	c6 81       	ldd	r28, Z+6	; 0x06
    1854:	d7 81       	ldd	r29, Z+7	; 0x07
    1856:	8e 01       	movw	r16, r28
    1858:	04 5f       	subi	r16, 0xF4	; 244
    185a:	1f 4f       	sbci	r17, 0xFF	; 255
    185c:	c8 01       	movw	r24, r16
    185e:	0e 94 78 03 	call	0x6f0	; 0x6f0 <uxListRemove>
    1862:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    1866:	81 11       	cpse	r24, r1
    1868:	1c c0       	rjmp	.+56     	; 0x18a2 <xTaskRemoveFromEventList+0x62>
    186a:	0a 50       	subi	r16, 0x0A	; 10
    186c:	11 09       	sbc	r17, r1
    186e:	c8 01       	movw	r24, r16
    1870:	0e 94 78 03 	call	0x6f0	; 0x6f0 <uxListRemove>
    1874:	8e 89       	ldd	r24, Y+22	; 0x16
    1876:	90 91 3b 16 	lds	r25, 0x163B	; 0x80163b <uxTopReadyPriority>
    187a:	98 17       	cp	r25, r24
    187c:	10 f4       	brcc	.+4      	; 0x1882 <xTaskRemoveFromEventList+0x42>
    187e:	80 93 3b 16 	sts	0x163B, r24	; 0x80163b <uxTopReadyPriority>
    1882:	90 e0       	ldi	r25, 0x00	; 0
    1884:	9c 01       	movw	r18, r24
    1886:	22 0f       	add	r18, r18
    1888:	33 1f       	adc	r19, r19
    188a:	22 0f       	add	r18, r18
    188c:	33 1f       	adc	r19, r19
    188e:	22 0f       	add	r18, r18
    1890:	33 1f       	adc	r19, r19
    1892:	82 0f       	add	r24, r18
    1894:	93 1f       	adc	r25, r19
    1896:	b8 01       	movw	r22, r16
    1898:	8f 58       	subi	r24, 0x8F	; 143
    189a:	99 4e       	sbci	r25, 0xE9	; 233
    189c:	0e 94 26 03 	call	0x64c	; 0x64c <vListInsertEnd>
    18a0:	05 c0       	rjmp	.+10     	; 0x18ac <xTaskRemoveFromEventList+0x6c>
    18a2:	b8 01       	movw	r22, r16
    18a4:	82 e5       	ldi	r24, 0x52	; 82
    18a6:	96 e1       	ldi	r25, 0x16	; 22
    18a8:	0e 94 26 03 	call	0x64c	; 0x64c <vListInsertEnd>
    18ac:	e0 91 95 16 	lds	r30, 0x1695	; 0x801695 <pxCurrentTCB>
    18b0:	f0 91 96 16 	lds	r31, 0x1696	; 0x801696 <pxCurrentTCB+0x1>
    18b4:	9e 89       	ldd	r25, Y+22	; 0x16
    18b6:	86 89       	ldd	r24, Z+22	; 0x16
    18b8:	89 17       	cp	r24, r25
    18ba:	20 f4       	brcc	.+8      	; 0x18c4 <xTaskRemoveFromEventList+0x84>
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	80 93 38 16 	sts	0x1638, r24	; 0x801638 <xYieldPending>
    18c2:	01 c0       	rjmp	.+2      	; 0x18c6 <xTaskRemoveFromEventList+0x86>
    18c4:	80 e0       	ldi	r24, 0x00	; 0
    18c6:	df 91       	pop	r29
    18c8:	cf 91       	pop	r28
    18ca:	1f 91       	pop	r17
    18cc:	0f 91       	pop	r16
    18ce:	08 95       	ret

000018d0 <vTaskInternalSetTimeOutState>:
    18d0:	20 91 37 16 	lds	r18, 0x1637	; 0x801637 <xNumOfOverflows>
    18d4:	fc 01       	movw	r30, r24
    18d6:	20 83       	st	Z, r18
    18d8:	20 91 3c 16 	lds	r18, 0x163C	; 0x80163c <xTickCount>
    18dc:	30 91 3d 16 	lds	r19, 0x163D	; 0x80163d <xTickCount+0x1>
    18e0:	32 83       	std	Z+2, r19	; 0x02
    18e2:	21 83       	std	Z+1, r18	; 0x01
    18e4:	08 95       	ret

000018e6 <xTaskCheckForTimeOut>:
    18e6:	cf 93       	push	r28
    18e8:	df 93       	push	r29
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	f8 94       	cli
    18ee:	0f 92       	push	r0
    18f0:	20 91 3c 16 	lds	r18, 0x163C	; 0x80163c <xTickCount>
    18f4:	30 91 3d 16 	lds	r19, 0x163D	; 0x80163d <xTickCount+0x1>
    18f8:	db 01       	movw	r26, r22
    18fa:	4d 91       	ld	r20, X+
    18fc:	5c 91       	ld	r21, X
    18fe:	4f 3f       	cpi	r20, 0xFF	; 255
    1900:	bf ef       	ldi	r27, 0xFF	; 255
    1902:	5b 07       	cpc	r21, r27
    1904:	e9 f0       	breq	.+58     	; 0x1940 <xTaskCheckForTimeOut+0x5a>
    1906:	ec 01       	movw	r28, r24
    1908:	e9 81       	ldd	r30, Y+1	; 0x01
    190a:	fa 81       	ldd	r31, Y+2	; 0x02
    190c:	a0 91 37 16 	lds	r26, 0x1637	; 0x801637 <xNumOfOverflows>
    1910:	b8 81       	ld	r27, Y
    1912:	ba 17       	cp	r27, r26
    1914:	19 f0       	breq	.+6      	; 0x191c <xTaskCheckForTimeOut+0x36>
    1916:	2e 17       	cp	r18, r30
    1918:	3f 07       	cpc	r19, r31
    191a:	a0 f4       	brcc	.+40     	; 0x1944 <xTaskCheckForTimeOut+0x5e>
    191c:	2e 1b       	sub	r18, r30
    191e:	3f 0b       	sbc	r19, r31
    1920:	24 17       	cp	r18, r20
    1922:	35 07       	cpc	r19, r21
    1924:	40 f4       	brcc	.+16     	; 0x1936 <xTaskCheckForTimeOut+0x50>
    1926:	fb 01       	movw	r30, r22
    1928:	42 1b       	sub	r20, r18
    192a:	53 0b       	sbc	r21, r19
    192c:	51 83       	std	Z+1, r21	; 0x01
    192e:	40 83       	st	Z, r20
    1930:	cf df       	rcall	.-98     	; 0x18d0 <vTaskInternalSetTimeOutState>
    1932:	80 e0       	ldi	r24, 0x00	; 0
    1934:	08 c0       	rjmp	.+16     	; 0x1946 <xTaskCheckForTimeOut+0x60>
    1936:	fb 01       	movw	r30, r22
    1938:	11 82       	std	Z+1, r1	; 0x01
    193a:	10 82       	st	Z, r1
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	03 c0       	rjmp	.+6      	; 0x1946 <xTaskCheckForTimeOut+0x60>
    1940:	80 e0       	ldi	r24, 0x00	; 0
    1942:	01 c0       	rjmp	.+2      	; 0x1946 <xTaskCheckForTimeOut+0x60>
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	08 95       	ret

00001950 <vTaskMissedYield>:
    1950:	81 e0       	ldi	r24, 0x01	; 1
    1952:	80 93 38 16 	sts	0x1638, r24	; 0x801638 <xYieldPending>
    1956:	08 95       	ret

00001958 <xTaskGetSchedulerState>:
    1958:	80 91 3a 16 	lds	r24, 0x163A	; 0x80163a <xSchedulerRunning>
    195c:	88 23       	and	r24, r24
    195e:	31 f0       	breq	.+12     	; 0x196c <xTaskGetSchedulerState+0x14>
    1960:	80 91 31 16 	lds	r24, 0x1631	; 0x801631 <uxSchedulerSuspended>
    1964:	88 23       	and	r24, r24
    1966:	21 f0       	breq	.+8      	; 0x1970 <xTaskGetSchedulerState+0x18>
    1968:	80 e0       	ldi	r24, 0x00	; 0
    196a:	08 95       	ret
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	08 95       	ret
    1970:	82 e0       	ldi	r24, 0x02	; 2
    1972:	08 95       	ret

00001974 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1974:	0f 93       	push	r16
    1976:	1f 93       	push	r17
    1978:	cf 93       	push	r28
    197a:	df 93       	push	r29
    197c:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    197e:	89 2b       	or	r24, r25
    1980:	79 f1       	breq	.+94     	; 0x19e0 <xTaskPriorityDisinherit+0x6c>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1982:	82 a1       	ldd	r24, Z+34	; 0x22
    1984:	81 50       	subi	r24, 0x01	; 1
    1986:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1988:	26 89       	ldd	r18, Z+22	; 0x16
    198a:	91 a1       	ldd	r25, Z+33	; 0x21
    198c:	29 17       	cp	r18, r25
    198e:	51 f1       	breq	.+84     	; 0x19e4 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1990:	81 11       	cpse	r24, r1
    1992:	2a c0       	rjmp	.+84     	; 0x19e8 <xTaskPriorityDisinherit+0x74>
    1994:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1996:	8f 01       	movw	r16, r30
    1998:	0e 5f       	subi	r16, 0xFE	; 254
    199a:	1f 4f       	sbci	r17, 0xFF	; 255
    199c:	c8 01       	movw	r24, r16
    199e:	0e 94 78 03 	call	0x6f0	; 0x6f0 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    19a2:	89 a1       	ldd	r24, Y+33	; 0x21
    19a4:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    19a6:	24 e0       	ldi	r18, 0x04	; 4
    19a8:	30 e0       	ldi	r19, 0x00	; 0
    19aa:	28 1b       	sub	r18, r24
    19ac:	31 09       	sbc	r19, r1
    19ae:	3d 87       	std	Y+13, r19	; 0x0d
    19b0:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    19b2:	90 91 3b 16 	lds	r25, 0x163B	; 0x80163b <uxTopReadyPriority>
    19b6:	98 17       	cp	r25, r24
    19b8:	10 f4       	brcc	.+4      	; 0x19be <xTaskPriorityDisinherit+0x4a>
    19ba:	80 93 3b 16 	sts	0x163B, r24	; 0x80163b <uxTopReadyPriority>
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	9c 01       	movw	r18, r24
    19c2:	22 0f       	add	r18, r18
    19c4:	33 1f       	adc	r19, r19
    19c6:	22 0f       	add	r18, r18
    19c8:	33 1f       	adc	r19, r19
    19ca:	22 0f       	add	r18, r18
    19cc:	33 1f       	adc	r19, r19
    19ce:	82 0f       	add	r24, r18
    19d0:	93 1f       	adc	r25, r19
    19d2:	b8 01       	movw	r22, r16
    19d4:	8f 58       	subi	r24, 0x8F	; 143
    19d6:	99 4e       	sbci	r25, 0xE9	; 233
    19d8:	0e 94 26 03 	call	0x64c	; 0x64c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	05 c0       	rjmp	.+10     	; 0x19ea <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    19e0:	80 e0       	ldi	r24, 0x00	; 0
    19e2:	03 c0       	rjmp	.+6      	; 0x19ea <xTaskPriorityDisinherit+0x76>
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	01 c0       	rjmp	.+2      	; 0x19ea <xTaskPriorityDisinherit+0x76>
    19e8:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    19ea:	df 91       	pop	r29
    19ec:	cf 91       	pop	r28
    19ee:	1f 91       	pop	r17
    19f0:	0f 91       	pop	r16
    19f2:	08 95       	ret

000019f4 <prvInsertTimerInActiveList>:
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    19f4:	fc 01       	movw	r30, r24
    19f6:	73 83       	std	Z+3, r23	; 0x03
    19f8:	62 83       	std	Z+2, r22	; 0x02
    19fa:	91 87       	std	Z+9, r25	; 0x09
    19fc:	80 87       	std	Z+8, r24	; 0x08
    19fe:	46 17       	cp	r20, r22
    1a00:	57 07       	cpc	r21, r23
    1a02:	90 f0       	brcs	.+36     	; 0x1a28 <prvInsertTimerInActiveList+0x34>
    1a04:	42 1b       	sub	r20, r18
    1a06:	53 0b       	sbc	r21, r19
    1a08:	84 85       	ldd	r24, Z+12	; 0x0c
    1a0a:	95 85       	ldd	r25, Z+13	; 0x0d
    1a0c:	48 17       	cp	r20, r24
    1a0e:	59 07       	cpc	r21, r25
    1a10:	e0 f4       	brcc	.+56     	; 0x1a4a <prvInsertTimerInActiveList+0x56>
    1a12:	bf 01       	movw	r22, r30
    1a14:	6e 5f       	subi	r22, 0xFE	; 254
    1a16:	7f 4f       	sbci	r23, 0xFF	; 255
    1a18:	80 91 9d 16 	lds	r24, 0x169D	; 0x80169d <pxOverflowTimerList>
    1a1c:	90 91 9e 16 	lds	r25, 0x169E	; 0x80169e <pxOverflowTimerList+0x1>
    1a20:	0e 94 47 03 	call	0x68e	; 0x68e <vListInsert>
    1a24:	80 e0       	ldi	r24, 0x00	; 0
    1a26:	08 95       	ret
    1a28:	42 17       	cp	r20, r18
    1a2a:	53 07       	cpc	r21, r19
    1a2c:	18 f4       	brcc	.+6      	; 0x1a34 <prvInsertTimerInActiveList+0x40>
    1a2e:	62 17       	cp	r22, r18
    1a30:	73 07       	cpc	r23, r19
    1a32:	68 f4       	brcc	.+26     	; 0x1a4e <prvInsertTimerInActiveList+0x5a>
    1a34:	bf 01       	movw	r22, r30
    1a36:	6e 5f       	subi	r22, 0xFE	; 254
    1a38:	7f 4f       	sbci	r23, 0xFF	; 255
    1a3a:	80 91 9f 16 	lds	r24, 0x169F	; 0x80169f <pxCurrentTimerList>
    1a3e:	90 91 a0 16 	lds	r25, 0x16A0	; 0x8016a0 <pxCurrentTimerList+0x1>
    1a42:	0e 94 47 03 	call	0x68e	; 0x68e <vListInsert>
    1a46:	80 e0       	ldi	r24, 0x00	; 0
    1a48:	08 95       	ret
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	08 95       	ret
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	08 95       	ret

00001a52 <prvCheckForValidListAndQueue>:
    1a52:	0f b6       	in	r0, 0x3f	; 63
    1a54:	f8 94       	cli
    1a56:	0f 92       	push	r0
    1a58:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <xTimerQueue>
    1a5c:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <xTimerQueue+0x1>
    1a60:	89 2b       	or	r24, r25
    1a62:	e1 f4       	brne	.+56     	; 0x1a9c <prvCheckForValidListAndQueue+0x4a>
    1a64:	8a ea       	ldi	r24, 0xAA	; 170
    1a66:	96 e1       	ldi	r25, 0x16	; 22
    1a68:	0e 94 14 03 	call	0x628	; 0x628 <vListInitialise>
    1a6c:	81 ea       	ldi	r24, 0xA1	; 161
    1a6e:	96 e1       	ldi	r25, 0x16	; 22
    1a70:	0e 94 14 03 	call	0x628	; 0x628 <vListInitialise>
    1a74:	8a ea       	ldi	r24, 0xAA	; 170
    1a76:	96 e1       	ldi	r25, 0x16	; 22
    1a78:	90 93 a0 16 	sts	0x16A0, r25	; 0x8016a0 <pxCurrentTimerList+0x1>
    1a7c:	80 93 9f 16 	sts	0x169F, r24	; 0x80169f <pxCurrentTimerList>
    1a80:	81 ea       	ldi	r24, 0xA1	; 161
    1a82:	96 e1       	ldi	r25, 0x16	; 22
    1a84:	90 93 9e 16 	sts	0x169E, r25	; 0x80169e <pxOverflowTimerList+0x1>
    1a88:	80 93 9d 16 	sts	0x169D, r24	; 0x80169d <pxOverflowTimerList>
    1a8c:	40 e0       	ldi	r20, 0x00	; 0
    1a8e:	65 e0       	ldi	r22, 0x05	; 5
    1a90:	8a e0       	ldi	r24, 0x0A	; 10
    1a92:	ee d8       	rcall	.-3620   	; 0xc70 <xQueueGenericCreate>
    1a94:	90 93 9c 16 	sts	0x169C, r25	; 0x80169c <xTimerQueue+0x1>
    1a98:	80 93 9b 16 	sts	0x169B, r24	; 0x80169b <xTimerQueue>
    1a9c:	0f 90       	pop	r0
    1a9e:	0f be       	out	0x3f, r0	; 63
    1aa0:	08 95       	ret

00001aa2 <xTimerCreateTimerTask>:
    1aa2:	ef 92       	push	r14
    1aa4:	ff 92       	push	r15
    1aa6:	0f 93       	push	r16
    1aa8:	d4 df       	rcall	.-88     	; 0x1a52 <prvCheckForValidListAndQueue>
    1aaa:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <xTimerQueue>
    1aae:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <xTimerQueue+0x1>
    1ab2:	89 2b       	or	r24, r25
    1ab4:	89 f0       	breq	.+34     	; 0x1ad8 <xTimerCreateTimerTask+0x36>
    1ab6:	0f 2e       	mov	r0, r31
    1ab8:	f9 e9       	ldi	r31, 0x99	; 153
    1aba:	ef 2e       	mov	r14, r31
    1abc:	f6 e1       	ldi	r31, 0x16	; 22
    1abe:	ff 2e       	mov	r15, r31
    1ac0:	f0 2d       	mov	r31, r0
    1ac2:	03 e0       	ldi	r16, 0x03	; 3
    1ac4:	20 e0       	ldi	r18, 0x00	; 0
    1ac6:	30 e0       	ldi	r19, 0x00	; 0
    1ac8:	40 e2       	ldi	r20, 0x20	; 32
    1aca:	53 e0       	ldi	r21, 0x03	; 3
    1acc:	60 e2       	ldi	r22, 0x20	; 32
    1ace:	74 e0       	ldi	r23, 0x04	; 4
    1ad0:	83 e2       	ldi	r24, 0x23	; 35
    1ad2:	9e e0       	ldi	r25, 0x0E	; 14
    1ad4:	61 db       	rcall	.-2366   	; 0x1198 <xTaskCreate>
    1ad6:	01 c0       	rjmp	.+2      	; 0x1ada <xTimerCreateTimerTask+0x38>
    1ad8:	80 e0       	ldi	r24, 0x00	; 0
    1ada:	0f 91       	pop	r16
    1adc:	ff 90       	pop	r15
    1ade:	ef 90       	pop	r14
    1ae0:	08 95       	ret

00001ae2 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    1ae2:	0f 93       	push	r16
    1ae4:	1f 93       	push	r17
    1ae6:	cf 93       	push	r28
    1ae8:	df 93       	push	r29
    1aea:	00 d0       	rcall	.+0      	; 0x1aec <xTimerGenericCommand+0xa>
    1aec:	1f 92       	push	r1
    1aee:	1f 92       	push	r1
    1af0:	cd b7       	in	r28, 0x3d	; 61
    1af2:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    1af4:	e0 91 9b 16 	lds	r30, 0x169B	; 0x80169b <xTimerQueue>
    1af8:	f0 91 9c 16 	lds	r31, 0x169C	; 0x80169c <xTimerQueue+0x1>
    1afc:	30 97       	sbiw	r30, 0x00	; 0
    1afe:	51 f1       	breq	.+84     	; 0x1b54 <xTimerGenericCommand+0x72>
    1b00:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1b02:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1b04:	5b 83       	std	Y+3, r21	; 0x03
    1b06:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    1b08:	9d 83       	std	Y+5, r25	; 0x05
    1b0a:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1b0c:	66 30       	cpi	r22, 0x06	; 6
    1b0e:	d4 f4       	brge	.+52     	; 0x1b44 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1b10:	23 df       	rcall	.-442    	; 0x1958 <xTaskGetSchedulerState>
    1b12:	82 30       	cpi	r24, 0x02	; 2
    1b14:	59 f4       	brne	.+22     	; 0x1b2c <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1b16:	20 e0       	ldi	r18, 0x00	; 0
    1b18:	a8 01       	movw	r20, r16
    1b1a:	be 01       	movw	r22, r28
    1b1c:	6f 5f       	subi	r22, 0xFF	; 255
    1b1e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b20:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <xTimerQueue>
    1b24:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <xTimerQueue+0x1>
    1b28:	cd d8       	rcall	.-3686   	; 0xcc4 <xQueueGenericSend>
    1b2a:	15 c0       	rjmp	.+42     	; 0x1b56 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1b2c:	20 e0       	ldi	r18, 0x00	; 0
    1b2e:	40 e0       	ldi	r20, 0x00	; 0
    1b30:	50 e0       	ldi	r21, 0x00	; 0
    1b32:	be 01       	movw	r22, r28
    1b34:	6f 5f       	subi	r22, 0xFF	; 255
    1b36:	7f 4f       	sbci	r23, 0xFF	; 255
    1b38:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <xTimerQueue>
    1b3c:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <xTimerQueue+0x1>
    1b40:	c1 d8       	rcall	.-3710   	; 0xcc4 <xQueueGenericSend>
    1b42:	09 c0       	rjmp	.+18     	; 0x1b56 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	ad 01       	movw	r20, r26
    1b48:	be 01       	movw	r22, r28
    1b4a:	6f 5f       	subi	r22, 0xFF	; 255
    1b4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b4e:	cf 01       	movw	r24, r30
    1b50:	4b d9       	rcall	.-3434   	; 0xde8 <xQueueGenericSendFromISR>
    1b52:	01 c0       	rjmp	.+2      	; 0x1b56 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    1b54:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    1b56:	0f 90       	pop	r0
    1b58:	0f 90       	pop	r0
    1b5a:	0f 90       	pop	r0
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	df 91       	pop	r29
    1b62:	cf 91       	pop	r28
    1b64:	1f 91       	pop	r17
    1b66:	0f 91       	pop	r16
    1b68:	08 95       	ret

00001b6a <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    1b6a:	af 92       	push	r10
    1b6c:	bf 92       	push	r11
    1b6e:	cf 92       	push	r12
    1b70:	df 92       	push	r13
    1b72:	ef 92       	push	r14
    1b74:	ff 92       	push	r15
    1b76:	0f 93       	push	r16
    1b78:	1f 93       	push	r17
    1b7a:	cf 93       	push	r28
    1b7c:	df 93       	push	r29
    1b7e:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    1b80:	41 dc       	rcall	.-1918   	; 0x1404 <xTaskGetTickCount>
    1b82:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    1b84:	80 91 97 16 	lds	r24, 0x1697	; 0x801697 <xLastTime.2378>
    1b88:	90 91 98 16 	lds	r25, 0x1698	; 0x801698 <xLastTime.2378+0x1>
    1b8c:	e8 16       	cp	r14, r24
    1b8e:	f9 06       	cpc	r15, r25
    1b90:	08 f0       	brcs	.+2      	; 0x1b94 <prvSampleTimeNow+0x2a>
    1b92:	47 c0       	rjmp	.+142    	; 0x1c22 <prvSampleTimeNow+0xb8>
    1b94:	2f c0       	rjmp	.+94     	; 0x1bf4 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1b96:	05 80       	ldd	r0, Z+5	; 0x05
    1b98:	f6 81       	ldd	r31, Z+6	; 0x06
    1b9a:	e0 2d       	mov	r30, r0
    1b9c:	a0 80       	ld	r10, Z
    1b9e:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1ba0:	c6 81       	ldd	r28, Z+6	; 0x06
    1ba2:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1ba4:	8e 01       	movw	r16, r28
    1ba6:	0e 5f       	subi	r16, 0xFE	; 254
    1ba8:	1f 4f       	sbci	r17, 0xFF	; 255
    1baa:	c8 01       	movw	r24, r16
    1bac:	0e 94 78 03 	call	0x6f0	; 0x6f0 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1bb0:	e9 89       	ldd	r30, Y+17	; 0x11
    1bb2:	fa 89       	ldd	r31, Y+18	; 0x12
    1bb4:	ce 01       	movw	r24, r28
    1bb6:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1bb8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bba:	81 30       	cpi	r24, 0x01	; 1
    1bbc:	d9 f4       	brne	.+54     	; 0x1bf4 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1bbe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bc0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bc2:	8a 0d       	add	r24, r10
    1bc4:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    1bc6:	a8 16       	cp	r10, r24
    1bc8:	b9 06       	cpc	r11, r25
    1bca:	60 f4       	brcc	.+24     	; 0x1be4 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1bcc:	9b 83       	std	Y+3, r25	; 0x03
    1bce:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1bd0:	d9 87       	std	Y+9, r29	; 0x09
    1bd2:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1bd4:	b8 01       	movw	r22, r16
    1bd6:	80 91 9f 16 	lds	r24, 0x169F	; 0x80169f <pxCurrentTimerList>
    1bda:	90 91 a0 16 	lds	r25, 0x16A0	; 0x8016a0 <pxCurrentTimerList+0x1>
    1bde:	0e 94 47 03 	call	0x68e	; 0x68e <vListInsert>
    1be2:	08 c0       	rjmp	.+16     	; 0x1bf4 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1be4:	00 e0       	ldi	r16, 0x00	; 0
    1be6:	10 e0       	ldi	r17, 0x00	; 0
    1be8:	20 e0       	ldi	r18, 0x00	; 0
    1bea:	30 e0       	ldi	r19, 0x00	; 0
    1bec:	a5 01       	movw	r20, r10
    1bee:	60 e0       	ldi	r22, 0x00	; 0
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	77 df       	rcall	.-274    	; 0x1ae2 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1bf4:	e0 91 9f 16 	lds	r30, 0x169F	; 0x80169f <pxCurrentTimerList>
    1bf8:	f0 91 a0 16 	lds	r31, 0x16A0	; 0x8016a0 <pxCurrentTimerList+0x1>
    1bfc:	80 81       	ld	r24, Z
    1bfe:	81 11       	cpse	r24, r1
    1c00:	ca cf       	rjmp	.-108    	; 0x1b96 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    1c02:	80 91 9d 16 	lds	r24, 0x169D	; 0x80169d <pxOverflowTimerList>
    1c06:	90 91 9e 16 	lds	r25, 0x169E	; 0x80169e <pxOverflowTimerList+0x1>
    1c0a:	90 93 a0 16 	sts	0x16A0, r25	; 0x8016a0 <pxCurrentTimerList+0x1>
    1c0e:	80 93 9f 16 	sts	0x169F, r24	; 0x80169f <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    1c12:	f0 93 9e 16 	sts	0x169E, r31	; 0x80169e <pxOverflowTimerList+0x1>
    1c16:	e0 93 9d 16 	sts	0x169D, r30	; 0x80169d <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	f6 01       	movw	r30, r12
    1c1e:	80 83       	st	Z, r24
    1c20:	02 c0       	rjmp	.+4      	; 0x1c26 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    1c22:	f6 01       	movw	r30, r12
    1c24:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    1c26:	f0 92 98 16 	sts	0x1698, r15	; 0x801698 <xLastTime.2378+0x1>
    1c2a:	e0 92 97 16 	sts	0x1697, r14	; 0x801697 <xLastTime.2378>

	return xTimeNow;
}
    1c2e:	c7 01       	movw	r24, r14
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	1f 91       	pop	r17
    1c36:	0f 91       	pop	r16
    1c38:	ff 90       	pop	r15
    1c3a:	ef 90       	pop	r14
    1c3c:	df 90       	pop	r13
    1c3e:	cf 90       	pop	r12
    1c40:	bf 90       	pop	r11
    1c42:	af 90       	pop	r10
    1c44:	08 95       	ret

00001c46 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <prvTimerTask+0x6>
    1c4c:	00 d0       	rcall	.+0      	; 0x1c4e <prvTimerTask+0x8>
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1c52:	ce 01       	movw	r24, r28
    1c54:	01 96       	adiw	r24, 0x01	; 1
    1c56:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1c58:	44 24       	eor	r4, r4
    1c5a:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    1c5c:	e1 2c       	mov	r14, r1
    1c5e:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1c60:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1c62:	c8 2e       	mov	r12, r24
    1c64:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1c66:	e0 91 9f 16 	lds	r30, 0x169F	; 0x80169f <pxCurrentTimerList>
    1c6a:	f0 91 a0 16 	lds	r31, 0x16A0	; 0x8016a0 <pxCurrentTimerList+0x1>
    1c6e:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    1c70:	88 23       	and	r24, r24
    1c72:	09 f4       	brne	.+2      	; 0x1c76 <prvTimerTask+0x30>
    1c74:	b5 c0       	rjmp	.+362    	; 0x1de0 <prvTimerTask+0x19a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1c76:	05 80       	ldd	r0, Z+5	; 0x05
    1c78:	f6 81       	ldd	r31, Z+6	; 0x06
    1c7a:	e0 2d       	mov	r30, r0
    1c7c:	a0 80       	ld	r10, Z
    1c7e:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    1c80:	bb db       	rcall	.-2186   	; 0x13f8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1c82:	c4 01       	movw	r24, r8
    1c84:	72 df       	rcall	.-284    	; 0x1b6a <prvSampleTimeNow>
    1c86:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1c88:	89 81       	ldd	r24, Y+1	; 0x01
    1c8a:	81 11       	cpse	r24, r1
    1c8c:	42 c0       	rjmp	.+132    	; 0x1d12 <prvTimerTask+0xcc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1c8e:	0a 15       	cp	r16, r10
    1c90:	1b 05       	cpc	r17, r11
			{
				( void ) xTaskResumeAll();
    1c92:	80 f1       	brcs	.+96     	; 0x1cf4 <prvTimerTask+0xae>
    1c94:	78 dc       	rcall	.-1808   	; 0x1586 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1c96:	e0 91 9f 16 	lds	r30, 0x169F	; 0x80169f <pxCurrentTimerList>
    1c9a:	f0 91 a0 16 	lds	r31, 0x16A0	; 0x8016a0 <pxCurrentTimerList+0x1>
    1c9e:	05 80       	ldd	r0, Z+5	; 0x05
    1ca0:	f6 81       	ldd	r31, Z+6	; 0x06
    1ca2:	e0 2d       	mov	r30, r0
    1ca4:	66 80       	ldd	r6, Z+6	; 0x06
    1ca6:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1ca8:	c3 01       	movw	r24, r6
    1caa:	02 96       	adiw	r24, 0x02	; 2
    1cac:	0e 94 78 03 	call	0x6f0	; 0x6f0 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1cb0:	d3 01       	movw	r26, r6
    1cb2:	1e 96       	adiw	r26, 0x0e	; 14
    1cb4:	8c 91       	ld	r24, X
    1cb6:	1e 97       	sbiw	r26, 0x0e	; 14
    1cb8:	81 30       	cpi	r24, 0x01	; 1
    1cba:	a1 f4       	brne	.+40     	; 0x1ce4 <prvTimerTask+0x9e>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1cbc:	1c 96       	adiw	r26, 0x0c	; 12
    1cbe:	6d 91       	ld	r22, X+
    1cc0:	7c 91       	ld	r23, X
    1cc2:	1d 97       	sbiw	r26, 0x0d	; 13
    1cc4:	6a 0d       	add	r22, r10
    1cc6:	7b 1d       	adc	r23, r11
    1cc8:	95 01       	movw	r18, r10
    1cca:	a8 01       	movw	r20, r16
    1ccc:	c3 01       	movw	r24, r6
    1cce:	92 de       	rcall	.-732    	; 0x19f4 <prvInsertTimerInActiveList>
    1cd0:	88 23       	and	r24, r24
    1cd2:	41 f0       	breq	.+16     	; 0x1ce4 <prvTimerTask+0x9e>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1cd4:	0e 2d       	mov	r16, r14
    1cd6:	1f 2d       	mov	r17, r15
    1cd8:	2e 2d       	mov	r18, r14
    1cda:	3f 2d       	mov	r19, r15
    1cdc:	a5 01       	movw	r20, r10
    1cde:	65 2d       	mov	r22, r5
    1ce0:	c3 01       	movw	r24, r6
    1ce2:	ff de       	rcall	.-514    	; 0x1ae2 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1ce4:	d3 01       	movw	r26, r6
    1ce6:	51 96       	adiw	r26, 0x11	; 17
    1ce8:	ed 91       	ld	r30, X+
    1cea:	fc 91       	ld	r31, X
    1cec:	52 97       	sbiw	r26, 0x12	; 18
    1cee:	c3 01       	movw	r24, r6
    1cf0:	19 95       	eicall
    1cf2:	6a c0       	rjmp	.+212    	; 0x1dc8 <prvTimerTask+0x182>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1cf4:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1cf6:	b5 01       	movw	r22, r10
    1cf8:	60 1b       	sub	r22, r16
    1cfa:	71 0b       	sbc	r23, r17
    1cfc:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <xTimerQueue>
    1d00:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    1d04:	bb d9       	rcall	.-3210   	; 0x107c <vQueueWaitForMessageRestricted>
    1d06:	3f dc       	rcall	.-1922   	; 0x1586 <xTaskResumeAll>
    1d08:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    1d0a:	5e c0       	rjmp	.+188    	; 0x1dc8 <prvTimerTask+0x182>
    1d0c:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    1d10:	5b c0       	rjmp	.+182    	; 0x1dc8 <prvTimerTask+0x182>
    1d12:	39 dc       	rcall	.-1934   	; 0x1586 <xTaskResumeAll>
    1d14:	59 c0       	rjmp	.+178    	; 0x1dc8 <prvTimerTask+0x182>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1d16:	89 81       	ldd	r24, Y+1	; 0x01
    1d18:	88 23       	and	r24, r24
    1d1a:	0c f4       	brge	.+2      	; 0x1d1e <prvTimerTask+0xd8>
    1d1c:	55 c0       	rjmp	.+170    	; 0x1dc8 <prvTimerTask+0x182>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1d1e:	ac 80       	ldd	r10, Y+4	; 0x04
    1d20:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    1d22:	f5 01       	movw	r30, r10
    1d24:	82 85       	ldd	r24, Z+10	; 0x0a
    1d26:	93 85       	ldd	r25, Z+11	; 0x0b
    1d28:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1d2a:	21 f0       	breq	.+8      	; 0x1d34 <prvTimerTask+0xee>
    1d2c:	c5 01       	movw	r24, r10
    1d2e:	02 96       	adiw	r24, 0x02	; 2
    1d30:	0e 94 78 03 	call	0x6f0	; 0x6f0 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1d34:	ce 01       	movw	r24, r28
    1d36:	06 96       	adiw	r24, 0x06	; 6
    1d38:	18 df       	rcall	.-464    	; 0x1b6a <prvSampleTimeNow>
    1d3a:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    1d3c:	89 81       	ldd	r24, Y+1	; 0x01
    1d3e:	08 2e       	mov	r0, r24
    1d40:	00 0c       	add	r0, r0
    1d42:	99 0b       	sbc	r25, r25
    1d44:	aa 0b       	sbc	r26, r26
    1d46:	bb 0b       	sbc	r27, r27
    1d48:	8a 30       	cpi	r24, 0x0A	; 10
    1d4a:	91 05       	cpc	r25, r1
    1d4c:	08 f0       	brcs	.+2      	; 0x1d50 <prvTimerTask+0x10a>
    1d4e:	3c c0       	rjmp	.+120    	; 0x1dc8 <prvTimerTask+0x182>
    1d50:	fc 01       	movw	r30, r24
    1d52:	88 27       	eor	r24, r24
    1d54:	ee 58       	subi	r30, 0x8E	; 142
    1d56:	ff 4f       	sbci	r31, 0xFF	; 255
    1d58:	8f 4f       	sbci	r24, 0xFF	; 255
    1d5a:	54 c0       	rjmp	.+168    	; 0x1e04 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1d5c:	2a 81       	ldd	r18, Y+2	; 0x02
    1d5e:	3b 81       	ldd	r19, Y+3	; 0x03
    1d60:	d5 01       	movw	r26, r10
    1d62:	1c 96       	adiw	r26, 0x0c	; 12
    1d64:	6d 91       	ld	r22, X+
    1d66:	7c 91       	ld	r23, X
    1d68:	1d 97       	sbiw	r26, 0x0d	; 13
    1d6a:	62 0f       	add	r22, r18
    1d6c:	73 1f       	adc	r23, r19
    1d6e:	c5 01       	movw	r24, r10
    1d70:	41 de       	rcall	.-894    	; 0x19f4 <prvInsertTimerInActiveList>
    1d72:	88 23       	and	r24, r24
    1d74:	49 f1       	breq	.+82     	; 0x1dc8 <prvTimerTask+0x182>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1d76:	d5 01       	movw	r26, r10
    1d78:	51 96       	adiw	r26, 0x11	; 17
    1d7a:	ed 91       	ld	r30, X+
    1d7c:	fc 91       	ld	r31, X
    1d7e:	52 97       	sbiw	r26, 0x12	; 18
    1d80:	c5 01       	movw	r24, r10
    1d82:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    1d84:	f5 01       	movw	r30, r10
    1d86:	86 85       	ldd	r24, Z+14	; 0x0e
    1d88:	81 30       	cpi	r24, 0x01	; 1
    1d8a:	f1 f4       	brne	.+60     	; 0x1dc8 <prvTimerTask+0x182>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1d8c:	4a 81       	ldd	r20, Y+2	; 0x02
    1d8e:	5b 81       	ldd	r21, Y+3	; 0x03
    1d90:	84 85       	ldd	r24, Z+12	; 0x0c
    1d92:	95 85       	ldd	r25, Z+13	; 0x0d
    1d94:	48 0f       	add	r20, r24
    1d96:	59 1f       	adc	r21, r25
    1d98:	0e 2d       	mov	r16, r14
    1d9a:	1f 2d       	mov	r17, r15
    1d9c:	2e 2d       	mov	r18, r14
    1d9e:	3f 2d       	mov	r19, r15
    1da0:	65 2d       	mov	r22, r5
    1da2:	c5 01       	movw	r24, r10
    1da4:	9e de       	rcall	.-708    	; 0x1ae2 <xTimerGenericCommand>
    1da6:	10 c0       	rjmp	.+32     	; 0x1dc8 <prvTimerTask+0x182>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1da8:	6a 81       	ldd	r22, Y+2	; 0x02
    1daa:	7b 81       	ldd	r23, Y+3	; 0x03
    1dac:	d5 01       	movw	r26, r10
    1dae:	1d 96       	adiw	r26, 0x0d	; 13
    1db0:	7c 93       	st	X, r23
    1db2:	6e 93       	st	-X, r22
    1db4:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1db6:	64 0f       	add	r22, r20
    1db8:	75 1f       	adc	r23, r21
    1dba:	9a 01       	movw	r18, r20
    1dbc:	c5 01       	movw	r24, r10
    1dbe:	1a de       	rcall	.-972    	; 0x19f4 <prvInsertTimerInActiveList>
    1dc0:	03 c0       	rjmp	.+6      	; 0x1dc8 <prvTimerTask+0x182>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    1dc2:	c5 01       	movw	r24, r10
    1dc4:	0e 94 b0 02 	call	0x560	; 0x560 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1dc8:	4e 2d       	mov	r20, r14
    1dca:	5f 2d       	mov	r21, r15
    1dcc:	6c 2d       	mov	r22, r12
    1dce:	7d 2d       	mov	r23, r13
    1dd0:	80 91 9b 16 	lds	r24, 0x169B	; 0x80169b <xTimerQueue>
    1dd4:	90 91 9c 16 	lds	r25, 0x169C	; 0x80169c <xTimerQueue+0x1>
    1dd8:	3f d8       	rcall	.-3970   	; 0xe58 <xQueueReceive>
    1dda:	81 11       	cpse	r24, r1
    1ddc:	9c cf       	rjmp	.-200    	; 0x1d16 <prvTimerTask+0xd0>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    1dde:	43 cf       	rjmp	.-378    	; 0x1c66 <prvTimerTask+0x20>
    1de0:	0b db       	rcall	.-2538   	; 0x13f8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1de2:	c4 01       	movw	r24, r8
    1de4:	c2 de       	rcall	.-636    	; 0x1b6a <prvSampleTimeNow>
    1de6:	8c 01       	movw	r16, r24
    1de8:	89 81       	ldd	r24, Y+1	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
    1dea:	81 11       	cpse	r24, r1
    1dec:	92 cf       	rjmp	.-220    	; 0x1d12 <prvTimerTask+0xcc>
    1dee:	e0 91 9d 16 	lds	r30, 0x169D	; 0x80169d <pxOverflowTimerList>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1df2:	f0 91 9e 16 	lds	r31, 0x169E	; 0x80169e <pxOverflowTimerList+0x1>
    1df6:	80 81       	ld	r24, Z
    1df8:	44 2d       	mov	r20, r4
    1dfa:	81 11       	cpse	r24, r1
    1dfc:	45 2d       	mov	r20, r5
    1dfe:	ae 2c       	mov	r10, r14
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    1e00:	bf 2c       	mov	r11, r15
    1e02:	79 cf       	rjmp	.-270    	; 0x1cf6 <prvTimerTask+0xb0>

00001e04 <__tablejump2__>:
    1e04:	ee 0f       	add	r30, r30
    1e06:	ff 1f       	adc	r31, r31
    1e08:	88 1f       	adc	r24, r24
    1e0a:	8b bf       	out	0x3b, r24	; 59
    1e0c:	07 90       	elpm	r0, Z+
    1e0e:	f6 91       	elpm	r31, Z
    1e10:	e0 2d       	mov	r30, r0
    1e12:	19 94       	eijmp

00001e14 <memcpy>:
    1e14:	fb 01       	movw	r30, r22
    1e16:	dc 01       	movw	r26, r24
    1e18:	02 c0       	rjmp	.+4      	; 0x1e1e <memcpy+0xa>
    1e1a:	01 90       	ld	r0, Z+
    1e1c:	0d 92       	st	X+, r0
    1e1e:	41 50       	subi	r20, 0x01	; 1
    1e20:	50 40       	sbci	r21, 0x00	; 0
    1e22:	d8 f7       	brcc	.-10     	; 0x1e1a <memcpy+0x6>
    1e24:	08 95       	ret

00001e26 <memset>:
    1e26:	dc 01       	movw	r26, r24
    1e28:	01 c0       	rjmp	.+2      	; 0x1e2c <memset+0x6>
    1e2a:	6d 93       	st	X+, r22
    1e2c:	41 50       	subi	r20, 0x01	; 1
    1e2e:	50 40       	sbci	r21, 0x00	; 0
    1e30:	e0 f7       	brcc	.-8      	; 0x1e2a <memset+0x4>
    1e32:	08 95       	ret

00001e34 <_exit>:
    1e34:	f8 94       	cli

00001e36 <__stop_program>:
    1e36:	ff cf       	rjmp	.-2      	; 0x1e36 <__stop_program>
